1. Any shell scripting program. 

1) Print Sum of Digits of a given number using command line argument

#!/bin/bash

number=$1

if [ -z "$1" ];
then
   echo Enter only one argument;
   exit 1;
fi   

sum=0

while [ $number -gt 0 ]; do
  digit=$((number%10));
  #echo $digit;
  sum=$((sum + digit));
  number=$((number / 10));
done

echo sum: $sum;





2) Write a shell script using function for following:
1)average of given numbers Code:

#!/bin/bash

average(){
 local sum=0
 local count=0

 for num in "$@"; do
   sum=$((sum+num))
   count=$((count+1))
 done

echo average: $((sum/count))
}

average "$@"






2) Max  digit from given number

#!/bin/bash

max_num(){
 local num=$1
 local max=0
 
 while [ $num -gt 0 ]; do
  digit=$((num%10))
  if [ $digit -gt $max ]; then
   max=$digit
  fi
  num=$((num/10))
 done
 
 echo max digit: $max

}

max_num $1





3) min digit  from given number

#!/bin/bash

min_num(){
 local num=$1
 local min=9
 
 while [ $num -gt 0 ]; do
  digit=$((num%10))
  if [ $digit -lt $min ]; then
   min=$digit
  fi
  num=$((num/10))
 done
 
 echo min digit: $min

}

min_num $1






3) Perform sorting on given array elements

#!/bin/bash

sort(){
 local array=("$@")
 local length=${#array[@]}
 
 for((i=0; i<length;i++)); do
   for((j=i+1;j<length;j++)); do
    	if [ "${array[i]}" -gt "${array[j]}" ]; then
     		temp="${array[i]}"
     		array[i]="${array[j]}"
     		array[j]="$temp"
    	fi
   done
 done
 
 echo "sorted array: ${array[@]}"
}
	
sort "$@"






4) Program to find factorial of a given number with and without recursion
1) Without recursion

#!/bin/bash

#Factorial without recursion

factorial(){

local number=$1
local result=1

while [ "$number" -gt 1 ]; do
 result=$((result*number))
 number=$((number-1))
done

echo "factorial: $result"
}

factorial $1





2) With recursion

#!/bin/bash

#Factorial with recursion

factorial_r(){

local number=$1

if [ "$number" -le 1 ]; then
 echo 1
else
 prev=$(factorial_r $((number-1)))
 echo $((number*prev))
fi
}

echo "factorial: $factorial$(factorial_r $1)"





5)Program to check file type and permission for a given file

#!/bin/bash

check(){

local file=$1

if [ -e"$file" ]; then
 echo "File exists."
 echo "File type: $(file "$file")"
 echo "Permissions: $(ls -l "$file" | awk '{print $1}')" 
else
 echo "File does not exist."
fi
}

check $1







6) Check entered string is palindrome or not?

#!/bin/bash

#Check if the given num is palindrome or not

check_pal(){

local str=$1
local length=${#str}
local reverse=""

i=$((length-1))
while [ $i -ge 0 ]; do
 char=$(echo "$str" | cut -c $((i+1)))
 reverse="$reverse$char"
 i=$((i-1))
done
echo "reversed str:$reverse"
echo "original str:$str"

if [ "$str" -eq "$reverse" ]; then
 echo "The string is a palindrome."
else
 echo "The string is not a palindrome."
fi

}

check_pal $1




7) count occrances of substring
#!/bin/bash

# Function to count occurrences of a substring
count_occurrences() {
    local string=$1
    local substring=$2
    local count=0

    # Loop through the string and count occurrences of the substring
    while [[ "$string" =~ $substring ]]; do
        ((count++))
        string=${string#*$substring}  # Remove the first occurrence of the substring
    done

    echo "Occurrences of '$substring': $count"
}

# Main script
echo "Enter the string:"
read string

echo "Enter the substring to count:"
read substring

count_occurrences "$string" "$substring"





8) reverse of a digit
#!/bin/bash

# Function to reverse the digits of a number
reverse_digits() {
    local number=$1
    local reversed=0

    while [ $number -gt 0 ]; do
        # Get the last digit of the number
        digit=$((number % 10))
        # Append it to the reversed number
        reversed=$((reversed * 10 + digit))
        # Remove the last digit from the number
        number=$((number / 10))
    done

    echo "Reversed number: $reversed"
}

# Main script
echo "Enter a number:"
read number

if ! [[ "$number" =~ ^[0-9]+$ ]]; then
    echo "Please enter a valid number."
    exit 1
fi

reverse_digits "$number"





9) Armstrong number
#!/bin/bash

# Function to check if the number is an Armstrong number
check_armstrong() {
    local number=$1
    local sum=0
    local temp=$number
    local digits=0

    # Count the number of digits in the number
    while [ $temp -gt 0 ]; do
        temp=$((temp / 10))
        digits=$((digits + 1))
    done

    # Reset temp to the original number
    temp=$number

    # Calculate the sum of digits raised to the power of the number of digits
    while [ $temp -gt 0 ]; do
        digit=$((temp % 10))
        sum=$((sum + digit ** digits))
        temp=$((temp / 10))
    done

    # Check if the sum is equal to the original number
    if [ $sum -eq $number ]; then
        echo "$number is an Armstrong number."
    else
        echo "$number is not an Armstrong number."
    fi
}

# Main script
echo "Enter a number:"
read number

if ! [[ "$number" =~ ^[0-9]+$ ]]; then
    echo "Please enter a valid number."
    exit 1
fi

check_armstrong "$number"







10) Rugved

#!/bin/bash

# Function for if-else statement 
if_else_demo() {
    read -p "Enter your age: " age
    if (( age < 18 )); then
        echo "You are a minor."
    elif (( age <= 65 )); then
        echo "You are an adult."
    else
        echo "You are a senior."
    fi
}

# Function for for loop to print numbers from start to end
for_loop_demo() {
    read -p "Enter the start number: " start
    read -p "Enter the end number: " end
    for (( i=start; i<=end; i++ )); do
        echo "Number $i"
    done
}

# Function to check if a number is prime
is_prime() {
    local num=$1
    if (( num <= 1 )); then
        return 1
    fi
    for (( i=2; i*i<=num; i++ )); do
        if (( num % i == 0 )); then
            return 1
        fi
    done
    return 0
}

# Function for while loop demonstration (prime numbers)
while_loop_demo() {
    read -p "Enter a start number: " start
    read -p "Enter an end number: " end
    while (( start <= end )); do
        if is_prime $start; then
            echo "Prime number: $start"
        fi
        ((start++))
    done
}

# Function to calculate factorial of a number
factorial() {
    local num=$1
    local factorial=1
    local i=1
    until (( i > num )); do
        factorial=$(( factorial * i ))
        ((i++))
    done
    echo $factorial
}

# Function for until loop demonstration (factorial)
until_loop_demo() {
    read -p "Enter a number to calculate factorial: " num
    result=$(factorial $num)
    echo "Factorial of $num is $result"
}

# Display the menu
while true; do
    echo "Menu:"
    echo "1) If-Else Statement"
    echo "2) For Loop"
    echo "3) While Loop"
    echo "4) Until Loop"
    echo "5) Exit"
    read -p "Choose an option: " choice

    case $choice in
        1)
            if_else_demo
            ;;
        2)
            for_loop_demo
            ;;
        3)
            while_loop_demo
            ;;
        4)
            until_loop_demo
            ;;
        5)
            echo "Exiting..."
            break
            ;;
        *)
            echo "Invalid option, please try again."
            ;;
    esac
done









11) Rugved 2


1.if else
Code-
 
#!/bin/bash
echo "Enter a number: "
read number
 
if [ $number -gt 0 ]; then
    echo "The number is positive."
elif [ $number -lt 0 ]; then
    echo "The number is negative."
else
    echo "The number is zero."
fi
 
 
2.for loop
Code-
#!/bin/bash
echo "Enter a number: "
read number
is_prime=1
for ((i=2; i<=number/2; i++))
do
    if [ $((number%i)) -eq 0 ]; then
        is_prime=0
        break
    fi
done
if [ $number -eq 1 ]; then
    echo "1 is neither prime nor composite."
elif [ $is_prime -eq 1 ]; then
    echo "$number is a prime number."
else
    echo "$number is not a prime number."
fi
3.while loop
Code-
#!/bin/bash
 
echo "Enter a number: "
read number
 
original_number=$number
reverse_number=0
 
while [ $number -gt 0 ]
do
    remainder=$((number % 10))
    reverse_number=$((reverse_number * 10 + remainder))
    number=$((number / 10))
done
 
if [ $original_number -eq $reverse_number ]; then
    echo "$original_number is a palindrome."
else
    echo "$original_number is not a palindrome."
fi
4.until
Code-
#!/bin/bash
echo "Enter a number: "
read number
sum=0
temp=$number
until [ $temp -eq 0 ]
do
    digit=$((temp % 10))
    sum=$((sum + digit ** 3))
    temp=$((temp / 10))
done
if [ $sum -eq $number ]; then
    echo "$number is an Armstrong number."
else
    echo "$number is not an Armstrong number."
fi
5.case
 #!/bin/bash
echo "Enter first number: "
read num1
echo "Enter second number: "
read num2
 
echo "Enter operation (+, -, *, /): "
read operation
 
case $operation in
    +)
        result=$((num1 + num2))
        echo "Result: $result"
        ;;
    -)
        result=$((num1 - num2))
        echo "Result: $result"
        ;;
    \*)
        result=$((num1 * num2))
        echo "Result: $result"
        ;;
    /)
        result=$((num1 / num2))
        echo "Result: $result"
        ;;
    *)
        echo "Invalid operation. Please enter +, -, *, or /."
        ;;
esac




3)	Perform sorting on given array elements

#!bin/bash
bubble_sort() {
    local arr=("$@")
    local n=${#arr[@]}
    local temp

    for ((i = 0; i < n-1; i++)); do
        for ((j = 0; j < n-i-1; j++)); do
            if [ "${arr[j]}" -gt "${arr[j+1]}" ]; then
                # Swap
                temp=${arr[j]}
                arr[j]=${arr[j+1]}
                arr[j+1]=$temp
            fi
        done
    done

    echo "Sorted array: ${arr[@]}"
}

# Main script
echo "Enter array elements separated by space:"
read -a array

bubble_sort "${array[@]}"



------------------------------------------------------------------------------------------------------------------------------

2.Write a program demonstrating use of different system calls. 

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <sys/utsname.h>

// Process related system calls
void fork_example();
void exit_example();
void wait_example();
void kill_example();
void exec_example();

// File related system calls
void open_read_write_example();
void link_unlink_example();
void stat_example();

// Communication related system calls
void pipe_example();
void fifo_example();

// Information related system calls
void getpid_example();
void getppid_example();
void uname_example();

int main() {
    int choice;
    while(1) {
        printf("\nMenu Driven System Call Demonstration\n");
        printf("1. Process related system calls\n");
        printf("2. File related system calls\n");
        printf("3. Communication related system calls\n");
        printf("4. Information related system calls\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        switch(choice) {
            case 1:
                printf("1. Fork\n2. Exit\n3. Wait\n4. Kill\n5. Exec\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
                if(choice == 1) fork_example();
                else if(choice == 2) exit_example();
                else if(choice == 3) wait_example();
                else if(choice == 4) kill_example();
                else if(choice == 5) exec_example();
                break;
            case 2:
                printf("1. Open, Read, Write, Close\n2. Link, Unlink\n3. Stat\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
                if(choice == 1) open_read_write_example();
                else if(choice == 2) link_unlink_example();
                else if(choice == 3) stat_example();
                break;
            case 3:
                printf("1. Pipe\n2. FIFO\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
                if(choice == 1) pipe_example();
                else if(choice == 2) fifo_example();
                break;
            case 4:
                printf("1. Get PID\n2. Get PPID\n3. Uname\n");
                printf("Enter your choice: ");
                scanf("%d", &choice);
                if(choice == 1) getpid_example();
                else if(choice == 2) getppid_example();
                else if(choice == 3) uname_example();
                break;
            case 5:
                exit(0);
            default:
                printf("Invalid choice! Please try again.\n");
        }
    }
    return 0;
}

// Process related system calls
void fork_example() {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Child process: PID = %d\n", getpid());
    } else {
        printf("Parent process: PID = %d\n", getpid());
        wait(NULL); // Wait for child to finish
    }
}

void exit_example() {
    printf("This process will terminate using exit().\n");
    exit(0);
}

void wait_example() {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Child process running. PID = %d\n", getpid());
        sleep(2); // Simulate some work in child
        exit(0);
    } else {
        printf("Parent waiting for child to terminate.\n");
        wait(NULL);
        printf("Child terminated.\n");
    }
}

void kill_example() {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Child process running. PID = %d\n", getpid());
        while(1); // Infinite loop
    } else {
        sleep(1);
        printf("Killing child process.\n");
        kill(pid, SIGKILL); // Terminate the child process
        wait(NULL);
    }
}

void exec_example() {
    pid_t pid = fork();
    if (pid == 0) {
        execl("/bin/ls", "ls", NULL); // Replace child process with `ls` command
    } else {
        wait(NULL);
    }
}

// File related system calls
void open_read_write_example() {
    int fd;
    char buffer[100];
    fd = open("demo_output.txt", O_CREAT | O_RDWR, 0644);
    if (fd == -1) {
        perror("Error opening file");
        return;
    }
    write(fd, "Hello, World!\n", 14);
    lseek(fd, 0, SEEK_SET); // Move to beginning of the file
    read(fd, buffer, sizeof(buffer));
    printf("File content: %s\n", buffer);
    close(fd);
}

void link_unlink_example() {
    link("demo_output.txt", "testfile_link.txt");
    printf("Link created.\n");
    unlink("testfile_link.txt");
    printf("Link removed.\n");
}

void stat_example() {
    struct stat fileStat;
    if(stat("demo_output.txt",&fileStat) < 0) {
        perror("Error getting file stats");
        return;
    }
    printf("Information for demo_output.txt:\n");
    printf("File Size: \t\t%ld bytes\n", fileStat.st_size);
    printf("Number of Links: \t%ld\n", fileStat.st_nlink);
    printf("File inode: \t\t%ld\n", fileStat.st_ino);
    printf("File Permissions: \t");
    printf( (S_ISDIR(fileStat.st_mode)) ? "d" : "-");
    printf( (fileStat.st_mode & S_IRUSR) ? "r" : "-");
    printf( (fileStat.st_mode & S_IWUSR) ? "w" : "-");
    printf( (fileStat.st_mode & S_IXUSR) ? "x" : "-");
    printf("\n");
}

// Communication related system calls
void pipe_example() {
    int fd[2];
    pid_t pid;
    char buffer[100];
    if (pipe(fd) == -1) {
        perror("Pipe failed");
        return;
    }
    pid = fork();
    if (pid == 0) {
        // Child process
        close(fd[0]); // Close read end
        write(fd[1], "Hello from child!\n", 18);
        close(fd[1]);
    } else {
        // Parent process
        close(fd[1]); // Close write end
        read(fd[0], buffer, sizeof(buffer));
        printf("Parent received: %s\n", buffer);
        close(fd[0]);
        wait(NULL);
    }
}

void fifo_example() {
    char *fifo = "/tmp/myfifo";
    mkfifo(fifo, 0666);
    if(fork() == 0) {
        int fd = open(fifo, O_WRONLY);
        write(fd, "Hello via FIFO!\n", 16);
        close(fd);
    } else {
        char buffer[100];
        int fd = open(fifo, O_RDONLY);
        read(fd, buffer, sizeof(buffer));
        printf("Parent received: %s\n", buffer);
        close(fd);
        wait(NULL);
    }
    unlink(fifo);
}

// Information related system calls
void getpid_example() {
    printf("Process ID: %d\n", getpid());
}

void getppid_example() {
    printf("Parent Process ID: %d\n", getppid());
}

void uname_example() {
    struct utsname buffer;
    if (uname(&buffer) < 0) {
        perror("Uname failed");
        return;
    }
    printf("Group ID: %d\n", getgid());
    printf("System page size: %ld bytes\n", sysconf(_SC_PAGESIZE));
    printf("System name: %s\n", buffer.sysname);
    printf("Node name: %s\n", buffer.nodename);
    printf("Release: %s\n", buffer.release);
    printf("Version: %s\n", buffer.version);
    printf("Machine: %s\n", buffer.machine);
}





/*1
1
2
1
3
1
4
1
5*/




2) Rugved sys call

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

// Function prototypes
void process_related_calls();
void file_related_calls();
void communication_related_calls();
void information_related_calls();

int main() {
    int choice;

    while (1) {
        printf("\nMenu Driven System Call Demonstration\n");
        printf("1. Process Related System Calls\n");
        printf("2. File Related System Calls\n");
        printf("3. Communication Related System Calls\n");
        printf("4. Information Related System Calls\n");
        printf("5. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                process_related_calls();
                break;
            case 2:
                file_related_calls();
                break;
            case 3:
                communication_related_calls();
                break;
            case 4:
                information_related_calls();
                break;
            case 5:
                exit(0);
            default:
                printf("Invalid choice, please try again.\n");
        }
    }

    return 0;
}

void process_related_calls() {
    pid_t pid;
    int status;

    printf("\nProcess Related System Calls\n");

    pid = fork();
    if (pid < 0) {
        perror("Fork failed");
        exit(1);
    } else if (pid == 0) { // Child process
        printf("Child Process ID: %d\n", getpid());
        execlp("/bin/ls", "ls", NULL); // exec system call
        exit(0); // exit system call
    } else { // Parent process
        printf("Parent Process ID: %d\n", getpid());
        wait(&status); // wait system call
        printf("Child process completed with status: %d\n", status);
    }
}

void file_related_calls() {
    int fd;
    char buffer[100];
    ssize_t bytes_read;

    printf("\nFile Related System Calls\n");

    fd = open("testfile.txt", O_CREAT | O_RDWR, 0644); // open system call
    if (fd < 0) {
        perror("Open failed");
        return;
    }

    write(fd, "Hello, World!\n", 14); // write system call

    lseek(fd, 0, SEEK_SET); // reposition file offset to the beginning
    bytes_read = read(fd, buffer, sizeof(buffer)); // read system call

    if (bytes_read > 0) {
        buffer[bytes_read] = '\0';
        printf("Read from file: %s", buffer);
    }

    close(fd); // close system call
    unlink("testfile.txt"); // unlink system call
}

void communication_related_calls() {
    int fd[2];
    pid_t pid;
    char write_msg[] = "Hello from parent!\n";
    char read_msg[100];

    printf("\nCommunication Related System Calls\n");

    if (pipe(fd) == -1) {
        perror("Pipe failed");
        return;
    }

    pid = fork();
    if (pid < 0) {
        perror("Fork failed");
        exit(1);
    } else if (pid == 0) { // Child process
        close(fd[1]); // Close write end of pipe
        read(fd[0], read_msg, sizeof(read_msg)); // Read from pipe
        printf("Child received: %s", read_msg);
        close(fd[0]); // Close read end of pipe
    } else { // Parent process
        close(fd[0]); // Close read end of pipe
        write(fd[1], write_msg, strlen(write_msg)); // Write to pipe
        close(fd[1]); // Close write end of pipe
        wait(NULL);
    }
}

void information_related_calls() {
    printf("\nInformation Related System Calls\n");

    printf("Sleeping for 2 seconds...\n");
    sleep(2); // sleep system call

    printf("Setting an alarm for 3 seconds...\n");
    alarm(3); // alarm system call

    printf("You will see this message before the alarm goes off.\n");

    // Delay to let the alarm go off
    sleep(4);
}





1. Process Related System Calls 

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>

void fork_example();
void exit_example();
void wait_example();
void kill_example();
void exec_example();

int main() {
    int choice;
    while(1) {
        printf("\nProcess Related System Calls\n");
        printf("1. Fork\n2. Exit\n3. Wait\n4. Kill\n5. Exec\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        if(choice == 1) fork_example();
        else if(choice == 2) exit_example();
        else if(choice == 3) wait_example();
        else if(choice == 4) kill_example();
        else if(choice == 5) exec_example();
        else printf("Invalid choice! Please try again.\n");
    }
    return 0;
}

// Process related system calls

void fork_example() {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Child process: PID = %d\n", getpid());
    } else {
        printf("Parent process: PID = %d\n", getpid());
        wait(NULL); // Wait for child to finish
    }
}

void exit_example() {
    printf("This process will terminate using exit().\n");
    exit(0);
}

void wait_example() {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Child process running. PID = %d\n", getpid());
        sleep(2); // Simulate some work in child
        exit(0);
    } else {
        printf("Parent waiting for child to terminate.\n");
        wait(NULL);
        printf("Child terminated.\n");
    }
}

void kill_example() {
    pid_t pid = fork();
    if (pid == 0) {
        printf("Child process running. PID = %d\n", getpid());
        while(1); // Infinite loop
    } else {
        sleep(1);
        printf("Killing child process.\n");
        kill(pid, SIGKILL); // Terminate the child process
        wait(NULL);
    }
}

void exec_example() {
    pid_t pid = fork();
    if (pid == 0) {
        execl("/bin/ls", "ls", NULL); // Replace child process with `ls` command
    } else {
        wait(NULL);
    }
}






2. File Related System Calls (file_calls.c)

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void open_read_write_example();
void link_unlink_example();
void stat_example();

int main() {
    int choice;
    while(1) {
        printf("\nFile Related System Calls\n");
        printf("1. Open, Read, Write, Close\n2. Link, Unlink\n3. Stat\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        if(choice == 1) open_read_write_example();
        else if(choice == 2) link_unlink_example();
        else if(choice == 3) stat_example();
        else printf("Invalid choice! Please try again.\n");
    }
    return 0;
}

// File related system calls

void open_read_write_example() {
    int fd;
    char buffer[100];
    fd = open("demo_output.txt", O_CREAT | O_RDWR, 0644);
    if (fd == -1) {
        perror("Error opening file");
        return;
    }
    write(fd, "Hello, World!\n", 14);
    lseek(fd, 0, SEEK_SET); // Move to beginning of the file
    read(fd, buffer, sizeof(buffer));
    printf("File content: %s\n", buffer);
    close(fd);
}

void link_unlink_example() {
    link("demo_output.txt", "testfile_link.txt");
    printf("Link created.\n");
    unlink("testfile_link.txt");
    printf("Link removed.\n");
}

void stat_example() {
    struct stat fileStat;
    if(stat("demo_output.txt", &fileStat) < 0) {
        perror("Error getting file stats");
        return;
    }
    printf("Information for demo_output.txt:\n");
    printf("File Size: \t\t%ld bytes\n", fileStat.st_size);
    printf("Number of Links: \t%ld\n", fileStat.st_nlink);
    printf("File inode: \t\t%ld\n", fileStat.st_ino);
    printf("File Permissions: \t");
    printf( (S_ISDIR(fileStat.st_mode)) ? "d" : "-");
    printf( (fileStat.st_mode & S_IRUSR) ? "r" : "-");
    printf( (fileStat.st_mode & S_IWUSR) ? "w" : "-");
    printf( (fileStat.st_mode & S_IXUSR) ? "x" : "-");
    printf("\n");
}





3. Communication Related System Calls (communication_calls.c)


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

void pipe_example();
void fifo_example();

int main() {
    int choice;
    while(1) {
        printf("\nCommunication Related System Calls\n");
        printf("1. Pipe\n2. FIFO\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        if(choice == 1) pipe_example();
        else if(choice == 2) fifo_example();
        else printf("Invalid choice! Please try again.\n");
    }
    return 0;
}

// Communication related system calls

void pipe_example() {
    int fd[2];
    pid_t pid;
    char buffer[100];
    if (pipe(fd) == -1) {
        perror("Pipe failed");
        return;
    }
    pid = fork();
    if (pid == 0) {
        // Child process
        close(fd[0]); // Close read end
        write(fd[1], "Hello from child!\n", 18);
        close(fd[1]);
    } else {
        // Parent process
        close(fd[1]); // Close write end
        read(fd[0], buffer, sizeof(buffer));
        printf("Parent received: %s\n", buffer);
        close(fd[0]);
        wait(NULL);
    }
}

void fifo_example() {
    char *fifo = "/tmp/myfifo";
    mkfifo(fifo, 0666);
    if(fork() == 0) {
        int fd = open(fifo, O_WRONLY);
        write(fd, "Hello via FIFO!\n", 16);
        close(fd);
    } else {
        char buffer[100];
        int fd = open(fifo, O_RDONLY);
        read(fd, buffer, sizeof(buffer));
        printf("Parent received: %s\n", buffer);
        close(fd);
        wait(NULL);
    }
    unlink(fifo);
}





4. Information Related System Calls (information_calls.c)
c
Copy code
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/utsname.h>

void getpid_example();
void getppid_example();
void uname_example();

int main() {
    int choice;
    while(1) {
        printf("\nInformation Related System Calls\n");
        printf("1. Get PID\n2. Get PPID\n3. Uname\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);
        if(choice == 1) getpid_example();
        else if(choice == 2) getppid_example();
        else if(choice == 3) uname_example();
        else printf("Invalid choice! Please try again.\n");
    }
    return 0;
}

// Information related system calls

void getpid_example() {
    printf("Process ID: %d\n", getpid());
}

void getppid_example() {
    printf("Parent Process ID: %d\n", getppid());
}

void uname_example() {
    struct utsname buffer;
    if (uname(&buffer) < 0) {
        perror("Uname failed");
        return;
    }
    printf("Group ID: %d\n", getgid());
    printf("System page size: %ld bytes\n", sysconf(_SC_PAGESIZE));
    printf("System name: %s\n", buffer.sysname);
    printf("Node name: %s\n", buffer.nodename);
    printf("Release: %s\n", buffer.release);
    printf("Version: %s\n", buffer.version);
    printf("Machine: %s\n", buffer.machine);
}



------------------------------------------------------------------------------------------------------------------------------


3.Implement multi threading for Matrix Operations using Pthreads.


#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#define SIZE 3
int matrix1[SIZE][SIZE], matrix2[SIZE][SIZE], result[SIZE][SIZE];

void *add_matrices(void *arg);
void *subtract_matrices(void *arg);
void *multiply_matrices(void *arg);
void initialize_matrices();
void display_matrix(int matrix[SIZE][SIZE]);

void initialize_matrices() {
    printf("Matrix Initialization:\n");
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            matrix1[i][j] = rand() % 10;
            matrix2[i][j] = rand() % 10;
        }
    }
    printf("Matrix 1:\n");
    display_matrix(matrix1);
    printf("Matrix 2:\n");
    display_matrix(matrix2);
}

void display_matrix(int matrix[SIZE][SIZE]) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
}

void *add_matrices(void *arg) {
    printf("Addition Thread Started.\n");
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            result[i][j] = matrix1[i][j] + matrix2[i][j];
        }
    }
    printf("Addition Result:\n");
    display_matrix(result);
    printf("Addition Thread Finished.\n");
    
    int *exit_status = malloc(sizeof(int));  
    *exit_status = 0;  
    pthread_exit(exit_status);  
}

void *subtract_matrices(void *arg) {
    printf("Subtraction Thread Started.\n");
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            result[i][j] = matrix1[i][j] - matrix2[i][j];
        }
    }
    printf("Subtraction Result:\n");
    display_matrix(result);
    printf("Subtraction Thread Finished.\n");
    
    int *exit_status = malloc(sizeof(int));  
    *exit_status = 1;
    pthread_exit(exit_status);  
}

void *multiply_matrices(void *arg) {
    printf("Multiplication Thread Started.\n");
    int *k = (int *)malloc(sizeof(int));  
    *k = 1;  

    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            result[i][j] = 0;
            for (*k = 0; *k < SIZE; (*k)++) {  
                result[i][j] += matrix1[i][*k] * matrix2[*k][j];
            }
        }
    }
    printf("Multiplication Result:\n");
    display_matrix(result);
    printf("Multiplication Thread Finished.\n");
    
    free(k);  
    
    int *exit_status = malloc(sizeof(int));  
    *exit_status = 2;  
    pthread_exit(exit_status);  
}

int main() {
    pthread_t tid1, tid2, tid3;
    void *status;

    initialize_matrices();

    if (pthread_create(&tid1, NULL, add_matrices, NULL) != 0) {
        perror("Error creating addition thread");
        return 1;
    }
    if (pthread_create(&tid2, NULL, subtract_matrices, NULL) != 0) {
        perror("Error creating subtraction thread");
        return 1;
    }
    if (pthread_create(&tid3, NULL, multiply_matrices, NULL) != 0) {
        perror("Error creating multiplication thread");
        return 1;
    }

    if (pthread_join(tid1, &status) != 0) {
        perror("Error joining addition thread");
        return 1;
    }
    printf("Addition Thread Exit Status: %d\n", *((int *)status));
    free(status);  

    if (pthread_join(tid2, &status) != 0) {
        perror("Error joining subtraction thread");
        return 1;
    }
    printf("Subtraction Thread Exit Status: %d\n", *((int *)status));
    free(status);  

    if (pthread_join(tid3, &status) != 0) {
        perror("Error joining multiplication thread");
        return 1;
    }
    printf("Multiplication Thread Exit Status: %d\n", *((int *)status));
    free(status);  

    return 0;
}





------------------------------------------------------------------------------------------------------------------------------


4. Implementation of Classical problems (reader writer)  using Threads and Mutex

1)
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t mutex;   
pthread_mutex_t wrt;     
int read_count = 0;      

// Reader function
void *reader(void *arg) {
    int reader_id = *((int *)arg); 
    printf("Reader %d is trying to read\n", reader_id);

    pthread_mutex_lock(&mutex);  
    read_count++;
    if (read_count == 1) {
        pthread_mutex_lock(&wrt);  
    }
    pthread_mutex_unlock(&mutex);  

    // Reading section
    printf("Reader %d is reading\n", reader_id);
    sleep(1);  
    printf("Reader %d has finished reading\n", reader_id);

    pthread_mutex_lock(&mutex);  
    read_count--;
    if (read_count == 0) {
        pthread_mutex_unlock(&wrt);  
    }
    pthread_mutex_unlock(&mutex);  

    return NULL;
}

// Writer function
void *writer(void *arg) {
    int writer_id = *((int *)arg); 
    printf("Writer %d is trying to access the resource\n", writer_id);

    pthread_mutex_lock(&wrt);  
    printf("Writer %d is writing\n", writer_id);
    sleep(1);  
    printf("Writer %d has finished writing\n", writer_id);

    pthread_mutex_unlock(&wrt);  

    return NULL;
}

int main() {
    pthread_t read[5], write[3];      
    int reader_ids[5], writer_ids[3];

    // Initialize the mutexes
    pthread_mutex_init(&mutex, NULL);
    pthread_mutex_init(&wrt, NULL);

    // Create reader and writer threads
    for (int i = 0; i < 5; i++) {
        reader_ids[i] = i + 1;
        pthread_create(&read[i], NULL, reader, &reader_ids[i]);
    }

    for (int i = 0; i < 3; i++) {
        writer_ids[i] = i + 1;
        pthread_create(&write[i], NULL, writer, &writer_ids[i]);
    }

    
    for (int i = 0; i < 5; i++) {
        pthread_join(read[i], NULL);  // Wait for all readers to finish
    }
    for (int i = 0; i < 3; i++) {
        pthread_join(write[i], NULL);  // Wait for all writers to finish
    }

   
    pthread_mutex_destroy(&mutex);
    pthread_mutex_destroy(&wrt);

    return 0;
}


2)
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <time.h>

int NUMBEROFREADERS;
int NUMBEROFWRITERS;

pthread_mutex_t mutex;   
pthread_mutex_t writeLock; 
int readCount = 0;   
int sharedData = 80; 

void readData(int readerId) {
    usleep(rand() % 2000000); // Simulate time for reading
    printf("\nReader %d read data: %d\n", readerId, sharedData);
}

void *reader(void *arg) {
    int readerId = *(int *)arg;
    printf("\nReader %d is trying to access critical region\n", readerId);

    pthread_mutex_lock(&mutex);
    readCount++;
    if (readCount == 1)
        pthread_mutex_lock(&writeLock);
    pthread_mutex_unlock(&mutex);

    printf("\nReader %d has got access to critical section\n", readerId);
    readData(readerId);

    pthread_mutex_lock(&mutex);
    readCount--;
    printf("\nReader %d has left the critical section\n", readerId);
    if (readCount == 0)
        pthread_mutex_unlock(&writeLock);
    pthread_mutex_unlock(&mutex);

}

int produceData() {
    return rand() % 100;
}

void writeOnCriticalSection(int data, int writerId) {
    sharedData = data;
    usleep(rand() % 2000000); // Simulate time for writing
    printf("\nWriter %d wrote data: %d\n", writerId, sharedData);
}

// Writer function
void *writer(void *arg) {
    int writerId = *(int *)arg;
    int dataToBeWritten = produceData();
    printf("\nWriter %d is trying to access critical region\n", writerId);

    pthread_mutex_lock(&writeLock);
    printf("\nWriter %d has got access to critical region\n", writerId);

    writeOnCriticalSection(dataToBeWritten, writerId);

    printf("\nWriter %d has left the critical section\n", writerId);
    pthread_mutex_unlock(&writeLock); 
}

int main() {
    printf("\nEnter total Number Of Readers:");
    scanf("%d",&NUMBEROFREADERS);
    printf("\nEnter total Number Of Writers:");
    scanf("%d",&NUMBEROFWRITERS);
    srand(time(NULL));

    pthread_t read[NUMBEROFREADERS], write[NUMBEROFWRITERS];  // 5 readers and 2 writers
    int readerIds[NUMBEROFREADERS], writerIds[NUMBEROFWRITERS];

    pthread_mutex_init(&mutex, NULL);
    pthread_mutex_init(&writeLock, NULL);

    for (int i = 0; i < NUMBEROFREADERS; i++) {
        readerIds[i] = i;
        pthread_create(&read[i], NULL, reader, &readerIds[i]);
    }

    for (int i = 0; i < NUMBEROFWRITERS; i++) {
        writerIds[i] = i;
        pthread_create(&write[i], NULL, writer, &writerIds[i]);
    }

    for (int i = 0; i < NUMBEROFREADERS; i++) {
        pthread_join(read[i], NULL);
    }
    for (int i = 0; i < NUMBEROFWRITERS; i++) {
        pthread_join(write[i], NULL);
    }

    pthread_mutex_destroy(&mutex);
    pthread_mutex_destroy(&writeLock);

    return 0;
}//RW Nme





3)

#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t mutex;   // Mutex for read_count
pthread_mutex_t wrt;     // Mutex for writer process
int read_count = 0;      // Number of readers

// Reader function
void *reader(void *arg) {
    int reader_id = *((int *)arg); // Reader ID
    printf("Reader %d is trying to read\n", reader_id);

    pthread_mutex_lock(&mutex);  // Lock mutex for read_count
    read_count++;
    if (read_count == 1) {
        pthread_mutex_lock(&wrt);  // First reader locks writer mutex
    }
    pthread_mutex_unlock(&mutex);  // Unlock mutex

    // Reading section
    printf("Reader %d is reading\n", reader_id);
    sleep(1);  // Simulate reading
    printf("Reader %d has finished reading\n", reader_id);

    pthread_mutex_lock(&mutex);  // Lock mutex for read_count
    read_count--;
    if (read_count == 0) {
        pthread_mutex_unlock(&wrt);  // Last reader unlocks writer mutex
    }
    pthread_mutex_unlock(&mutex);  // Unlock mutex

    return NULL;
}

// Writer function
void *writer(void *arg) {
    int writer_id = *((int *)arg); // Writer ID
    printf("Writer %d is trying to access the resource\n", writer_id);

    pthread_mutex_lock(&wrt);  // Lock writer mutex
    printf("Writer %d is writing\n", writer_id);
    sleep(1);  // Simulate writing
    printf("Writer %d has finished writing\n", writer_id);

    pthread_mutex_unlock(&wrt);  // Unlock writer mutex

    return NULL;
}

int main() {
    pthread_t read[5], write[3];  // 5 readers and 3 writers
    int reader_ids[5], writer_ids[3];

    // Initialize the mutexes
    pthread_mutex_init(&mutex, NULL);
    pthread_mutex_init(&wrt, NULL);

    // Create reader and writer threads
    for (int i = 0; i < 5; i++) {
        reader_ids[i] = i + 1;
        pthread_create(&read[i], NULL, reader, &reader_ids[i]);
    }

    for (int i = 0; i < 3; i++) {
        writer_ids[i] = i + 1;
        pthread_create(&write[i], NULL, writer, &writer_ids[i]);
    }

    // Join reader and writer threads
    for (int i = 0; i < 5; i++) {
        pthread_join(read[i], NULL);
    }
    for (int i = 0; i < 3; i++) {
        pthread_join(write[i], NULL);
    }

    // Destroy the mutexes
    pthread_mutex_destroy(&mutex);
    pthread_mutex_destroy(&wrt);

    return 0;
}//RW me



------------------------------------------------------------------------------------------------------------------------------


6. Implementation of Classical problems (reader writer) using Threads and Semaphore.

1)
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

sem_t mutex;  
sem_t wrt;    
int read_count = 0;  

// Reader function
void *reader(void *arg) {
    int reader_id = *((int *)arg);  // Reader ID
    printf("Reader %d is trying to read\n", reader_id);

    sem_wait(&mutex);  // Protect read_count
    read_count++;
    if (read_count == 1) {
        sem_wait(&wrt);  // If first reader, lock writer semaphore
    }
    sem_post(&mutex);  // Release protection of read_count

    // Reading section
    printf("Reader %d is reading\n", reader_id);
    sleep(1);  // Simulate reading
    printf("Reader %d has finished reading\n", reader_id);

    sem_wait(&mutex);  // Protect read_count
    read_count--;
    if (read_count == 0) {
        sem_post(&wrt);  // If last reader, unlock writer semaphore
    }
    sem_post(&mutex);  // Release protection of read_count

    return NULL;
}

// Writer function
void *writer(void *arg) {
    int writer_id = *((int *)arg);  // Writer ID
    printf("Writer %d is trying to access the resource\n", writer_id);

    sem_wait(&wrt);  // Lock writer semaphore (no readers or other writers)
    printf("Writer %d is writing\n", writer_id);
    sleep(1);  // Simulate writing
    printf("Writer %d has finished writing\n", writer_id);

    sem_post(&wrt);  // Release writer semaphore

    return NULL;
}

int main() {
    pthread_t read[5], write[3];  // 5 readers and 3 writers
    int reader_ids[5], writer_ids[3];

    // Initialize the semaphores
    sem_init(&mutex, 0, 1);  // Binary semaphore for read_count protection
    sem_init(&wrt, 0, 1);    // Binary semaphore for writer process

    // Create reader and writer threads
    for (int i = 0; i < 5; i++) {
        reader_ids[i] = i + 1;
        pthread_create(&read[i], NULL, reader, &reader_ids[i]);
    }

    for (int i = 0; i < 3; i++) {
        writer_ids[i] = i + 1;
        pthread_create(&write[i], NULL, writer, &writer_ids[i]);
    }

    // Join reader and writer threads
    for (int i = 0; i < 5; i++) {
        pthread_join(read[i], NULL);
    }
    for (int i = 0; i < 3; i++) {
        pthread_join(write[i], NULL);
    }

    // Destroy the semaphores
    sem_destroy(&mutex);
    sem_destroy(&wrt);

    return 0;
}




2)


#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#include <time.h>
#include <stdlib.h>
int NUMBEROFREADERS;
int NUMBEROFWRITERS;

sem_t s;  
sem_t wrt;    
int readCount = 0;  
int sharedData = 80;

void readData(int readerId)
{
    usleep(rand() % 2000000);//Reading requires time.
    printf("\nRead Data:%d from Reader Number:%d\n", sharedData,readerId);
}

void *reader(void *arg) {
    int readerId = *(int *)arg;  
    printf("\nReader %d is trying to access critical region\n", readerId);

    sem_wait(&s);  
    readCount++;
    if (readCount == 1)
        sem_wait(&wrt);  
    sem_post(&s);  

    printf("\nReader %d has got access to critical section\n",readerId);
    readData(readerId);
   

    sem_wait(&s);
    readCount--;
    printf("\nReader %d has left the critical section\n",readerId);
    if (readCount == 0)
        sem_post(&wrt);  
    sem_post(&s);  

}

int produceData()
{
    return rand() %100;
}

void writeOnCriticalSection(int data,int writerId)
{
    sharedData = data;
    usleep(rand() % 2000000);//Writing requires time
    printf("\nWriter %d has wrote. Data Now:%d\n", writerId,sharedData);
}

// Writer function
void *writer(void *arg) {
    int writerId = *((int *)arg); 
    int dataToBeWritten = produceData();
    printf("\nWriter %d is trying to access critical region\n", writerId);

    sem_wait(&wrt);     
    printf("\nWriter %d has got access to critical region\n",writerId);
    writeOnCriticalSection(dataToBeWritten,writerId);
    printf("\nWriter %d has left the critical section\n",writerId);
    sem_post(&wrt);  

}

int main() {
    srand(time(NULL));
    printf("\nEnter total number Of Readers:");
    scanf("%d",&NUMBEROFREADERS);
    printf("\nEnter total number of Writers:");
    scanf("%d",&NUMBEROFWRITERS);

    pthread_t read[NUMBEROFREADERS], write[NUMBEROFWRITERS];
    int readerIds[NUMBEROFREADERS], writerIds[NUMBEROFWRITERS];

    sem_init(&s, 0, 1);  
    sem_init(&wrt, 0, 1);    

    for (int i = 0; i < NUMBEROFREADERS; i++) {
        readerIds[i] = i;
        pthread_create(&read[i], NULL, reader, &readerIds[i]);
    }

    for (int i = 0; i < NUMBEROFWRITERS; i++) {
        writerIds[i] = i;
        pthread_create(&write[i], NULL, writer, &writerIds[i]);
    }

    for (int i = 0; i < NUMBEROFREADERS; i++) {
        pthread_join(read[i], NULL);
    }
    for (int i = 0; i < NUMBEROFWRITERS; i++) {
        pthread_join(write[i], NULL);
    }

    sem_destroy(&s);
    sem_destroy(&wrt);

    return 0;
}



------------------------------------------------------------------------------------------------------------------------------


5.Implementation of Classical problems( producer consumer)  using Threads and Mutex

1)
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define BUFFER_SIZE 5  // Buffer size

int buffer[BUFFER_SIZE];  // Shared buffer
int count = 0;  // Counter to track buffer fill level

pthread_mutex_t mutex;  // Mutex for critical section
pthread_cond_t cond_full;  // Condition variable for buffer full
pthread_cond_t cond_empty;  // Condition variable for buffer empty

// Function to display the buffer's current state
void displayBuffer() {
    printf("Buffer: [ ");
    for (int i = 0; i < BUFFER_SIZE; i++) {
        if (i < count)
            printf("%d ", buffer[i]);
        else
            printf("- ");  // Empty slot
    }
    printf("] ");
    
    if (count == 0) {
        printf("(Buffer is empty)\n");
    } else if (count == BUFFER_SIZE) {
        printf("(Buffer is full)\n");
    } else {
        printf("\n");
    }
}

// Producer function
void* producer(void* arg) {
    while (1) {
        int item = rand() % 100;  // Produce a random item

        pthread_mutex_lock(&mutex);  // Lock the mutex before accessing the buffer

        // Wait if buffer is full
        while (count == BUFFER_SIZE) {
            printf("Producer waiting, buffer full...\n");
            pthread_cond_wait(&cond_full, &mutex);
        }

        // Produce item into buffer
        buffer[count] = item;
        count++;
        printf("Producer produced: %d\n", item);
        displayBuffer();  // Display buffer state

        // Signal that the buffer is no longer empty
        pthread_cond_signal(&cond_empty);

        pthread_mutex_unlock(&mutex);  // Unlock the mutex

        sleep(rand() % 2);  // Simulate production time
    }
}

// Consumer function
void* consumer(void* arg) {
    while (1) {
        pthread_mutex_lock(&mutex);  // Lock the mutex before accessing the buffer

        // Wait if buffer is empty
        while (count == 0) {
            printf("Consumer waiting, buffer empty...\n");
            pthread_cond_wait(&cond_empty, &mutex);
        }

        // Consume item from buffer
        int item = buffer[--count];
        printf("Consumer consumed: %d\n", item);
        displayBuffer();  // Display buffer state

        // Signal that the buffer is no longer full
        pthread_cond_signal(&cond_full);

        pthread_mutex_unlock(&mutex);  // Unlock the mutex

        sleep(rand() % 2);  // Simulate consumption time
    }
}

int main() {
    pthread_t prod_thread, cons_thread;

    // Initialize mutex and condition variables
    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&cond_full, NULL);
    pthread_cond_init(&cond_empty, NULL);

    // Create producer and consumer threads
    pthread_create(&prod_thread, NULL, producer, NULL);
    pthread_create(&cons_thread, NULL, consumer, NULL);

    // Wait for threads to finish (optional, typically runs indefinitely)
    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);

    // Clean up
    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond_full);
    pthread_cond_destroy(&cond_empty);

    return 0;
}







2)

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <time.h>

#define BUFFER_SIZE 5  

int buffer[BUFFER_SIZE];  
int count = 0;            

pthread_mutex_t mutex;  // For mutual exclusion
pthread_cond_t bufferNotFull;  // Condition variable to check if the buffer is not full
pthread_cond_t bufferNotEmpty;  // Condition variable to check if the buffer is not empty

void displayBuffer() {
    printf("[ ");
    for (int i = 0; i < BUFFER_SIZE; i++) {
        if (i < count)
            printf("%d ", buffer[i]);
        else
            printf("- "); 
    }
    printf("] ");
    
    if (count == 0) {
        printf("(Buffer is empty)\n");
    } else if (count == BUFFER_SIZE) {
        printf("(Buffer is full)\n");
    } else {
        printf("\n");
    }
}

int produceItem() {
    return rand() % 100;
}

void addElementToBuffer(int item) {
    buffer[count] = item;  
    printf("\nElement %d has been added to buffer\n", item);
    count++;
}

void* producer(void* arg) {
    while (1) {
        int item = produceItem();  
        printf("\nProducer is trying to access critical section\n");

        pthread_mutex_lock(&mutex);  // Lock mutex to enter critical section
        
        // Wait until buffer is full
        while (count == BUFFER_SIZE) {
            printf("\nProducer waiting, buffer is full\n");
            pthread_cond_wait(&bufferNotFull, &mutex);
        }   

        printf("\nProducer has got access to critical section\n");
        addElementToBuffer(item);
        printf("\nBuffer after adding element:");
        displayBuffer();  

        printf("\nProducer has left the critical section\n");
        pthread_cond_signal(&bufferNotEmpty);  // Signal consumer that buffer is not empty
        pthread_mutex_unlock(&mutex);  // Unlock mutex after leaving critical section

        usleep(rand() % 2000000);  // Simulate time taken to produce an item
    }
}

int removeElementFromBuffer() {
    count--;
    int item = buffer[count];  
    return item;
}

void consumeItem(int item) {
    printf("\nElement %d has been consumed\n", item);
}

void* consumer(void* arg) {
    while (1) {
        printf("\nConsumer is trying to access critical section\n");

        pthread_mutex_lock(&mutex);  // Lock mutex to enter critical section
        
        // Wait until buffer is not empty
        while (count == 0) {
            printf("\nConsumer waiting, buffer is empty\n");
            pthread_cond_wait(&bufferNotEmpty, &mutex);
        }

        printf("\nConsumer has got access to critical section\n");
        
        int item = removeElementFromBuffer();  
        printf("\nBuffer after removing element:");
        displayBuffer();  

        printf("\nConsumer has left the critical section\n");
        pthread_cond_signal(&bufferNotFull);  
        pthread_mutex_unlock(&mutex); 
        
        consumeItem(item);

        usleep(rand() % 2000000);  
    }
}

int main() {
    srand(time(NULL));
    pthread_t prod_thread, cons_thread;

    pthread_mutex_init(&mutex, NULL);
    pthread_cond_init(&bufferNotFull, NULL);
    pthread_cond_init(&bufferNotEmpty, NULL);

    pthread_create(&prod_thread, NULL, producer, NULL);
    pthread_create(&cons_thread, NULL, consumer, NULL);

    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&bufferNotFull);
    pthread_cond_destroy(&bufferNotEmpty);

    return 0;
}



------------------------------------------------------------------------------------------------------------------------------



7.Implementation of Classical problems (producer consumer,) using Threads and Semaphore.


1)
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define BUFFER_SIZE 5  // Reduced buffer size for quicker full/empty demonstration

int buffer[BUFFER_SIZE];  // Shared buffer
int count = 0;            // Counter for items in the buffer

sem_t empty;  // Semaphore for empty slots
sem_t full;   // Semaphore for full slots
pthread_mutex_t mutex;  // Mutex for critical section

// Function to display the buffer's current state
void displayBuffer() {
    printf("Buffer: [ ");
    for (int i = 0; i < BUFFER_SIZE; i++) {
        if (i < count)
            printf("%d ", buffer[i]);
        else
            printf("- ");  // Empty slot
    }
    printf("] ");
    
    if (count == 0) {
        printf("(Buffer is empty)\n");
    } else if (count == BUFFER_SIZE) {
        printf("(Buffer is full)\n");
    } else {
        printf("\n");
    }
}

// Producer function
void* producer(void* arg) {
    while (1) {
        int item = rand() % 100;  // Produce a random item

        sem_wait(&empty);  // Wait for an empty slot
        pthread_mutex_lock(&mutex);  // Wait to access the buffer

        buffer[count] = item;  // Produce item into buffer
        count++;
        printf("Producer produced: %d\n", item);
        displayBuffer();  // Display buffer state

        pthread_mutex_unlock(&mutex);  // Release buffer
        sem_post(&full);  // Signal that a full slot is available

        sleep(rand() % 2);  // Simulate production time
    }
}

// Consumer function
void* consumer(void* arg) {
    while (1) {
        sem_wait(&full);  // Wait for a full slot
        pthread_mutex_lock(&mutex);  // Wait to access buffer

        int item = buffer[--count];  // Consume item from buffer
        printf("Consumer consumed: %d\n", item);
        displayBuffer();  // Display buffer state

        pthread_mutex_unlock(&mutex);  // Release buffer
        sem_post(&empty);  // Signal that an empty slot is available

        sleep(rand() % 2);  // Simulate consumption time
    }
}

int main() {
    pthread_t prod_thread, cons_thread;

    // Initialize semaphores and mutex
    sem_init(&empty, 0, BUFFER_SIZE);  // Initially, all slots are empty
    sem_init(&full, 0, 0);  // Initially, no slots are full
    pthread_mutex_init(&mutex, NULL);

    // Create producer and consumer threads
    pthread_create(&prod_thread, NULL, producer, NULL);
    pthread_create(&cons_thread, NULL, consumer, NULL);

    // Wait for threads to finish (optional, typically runs indefinitely)
    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);

    // Clean up
    sem_destroy(&empty);
    sem_destroy(&full);
    pthread_mutex_destroy(&mutex);

    return 0;
}






2)
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>
#include <time.h>

#define BUFFER_SIZE 5  

int buffer[BUFFER_SIZE];  
int count = 0;            

sem_t empty;
sem_t full;   
sem_t s;  


void displayBuffer() {
    printf("[ ");
    for (int i = 0; i < BUFFER_SIZE; i++) {
        if (i < count)
            printf("%d ", buffer[i]);
        else
            printf("- "); 
    }
    printf("] ");
    
    if (count == 0) {
        printf("(Buffer is empty)\n");
    } else if (count == BUFFER_SIZE) {
        printf("(Buffer is full)\n");
    } else {
        printf("\n");
    }
}

int produceItem()
{
    return rand() % 100;
}

void addElementToBuffer(int item)
{
    buffer[count] = item;  
    printf("\nElement %d has been added to buffer\n",item);
    count++;
}

void* producer(void* arg) {
    while (1) {
        int item = produceItem();  
        printf("\nProducer is trying to access critical section\n");

        sem_wait(&empty); 
        sem_wait(&s);  

        printf("\nProducer has got access to critical section\n");
        addElementToBuffer(item);
        printf("\nBuffer after adding element:");
        displayBuffer();  

        printf("\nProducer has left the critical section\n");
        sem_post(&full);
        sem_post(&s);  

        usleep(rand() % 2000000);  
    }
}

int removeElementFromBuffer()
{
    count--;
    int item = buffer[count];  
    return item;
}

void consumeItem(int item)
{
    printf("\nElement %d has been consumed\n",item);
}


void* consumer(void* arg) {
    while (1) {
        printf("\nConsumer is trying to access critical section\n");
        sem_wait(&full);  
        sem_wait(&s);  

        printf("\nConsumer has got access to critical section\n");
        
        int item = removeElementFromBuffer();  
        printf("\nBuffer after removing element:");
        displayBuffer();  

        printf("\nConsumer has left the critical section\n");
        sem_post(&empty);  
        sem_post(&s);  
        consumeItem(item);

        usleep(rand() % 2000000);  
    }
}

int main() {
    srand(time(NULL));
    pthread_t prod_thread, cons_thread;


    sem_init(&empty, 0, BUFFER_SIZE);  
    sem_init(&full, 0, 0); 
    sem_init(&s, 0, 1);

    pthread_create(&prod_thread, NULL, producer, NULL);
    pthread_create(&cons_thread, NULL, consumer, NULL);

    // Wait for threads to finish (optional, typically runs indefinitely)
    pthread_join(prod_thread, NULL);
    pthread_join(cons_thread, NULL);


    sem_destroy(&empty);
    sem_destroy(&full);
    sem_destroy(&s);

    return 0;
}







------------------------------------------------------------------------------------------------------------------------------



8.Implementation of Classical problems (dining philosopher) using Threads and Semaphore. 


Rugved)

#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <unistd.h>

#define NUM_PHILOSOPHERS 5

// Semaphores for each fork
sem_t forks[NUM_PHILOSOPHERS];

// Philosopher function
void* philosopher(void* num) {
    int i = *(int*)num;
    while (1) {
        printf("Philosopher %d is thinking...\n", i);
        //sleep(1);  // Simulate thinking

        // Asymmetry: Philosopher 0 picks up the right fork first
        if (i == 0) {
            sem_wait(&forks[(i + 1) % NUM_PHILOSOPHERS]);  // Pick up right fork first
            printf("Philosopher %d picked up right fork %d\n", i, (i + 1) % NUM_PHILOSOPHERS);
            sem_wait(&forks[i]);  // Then pick up left fork
            printf("Philosopher %d picked up left fork %d\n", i, i);
        } else {
            sem_wait(&forks[i]);  // Pick up left fork first
            printf("Philosopher %d picked up left fork %d\n", i, i);
            sem_wait(&forks[(i + 1) % NUM_PHILOSOPHERS]);  // Then pick up right fork
            printf("Philosopher %d picked up right fork %d\n", i, (i + 1) % NUM_PHILOSOPHERS);
        }

        // Eating
        printf("Philosopher %d is eating...\n", i);
        //sleep(1);  // Simulate eating

        // Put down the forks
        sem_post(&forks[i]);  // Put down left fork
        printf("Philosopher %d put down left fork %d\n", i, i);
        sem_post(&forks[(i + 1) % NUM_PHILOSOPHERS]);  // Put down right fork
        printf("Philosopher %d put down right fork %d\n", i, (i + 1) % NUM_PHILOSOPHERS);

        // Back to thinking
    }
}

int main() {
    pthread_t philosophers[NUM_PHILOSOPHERS];
    int philosopher_ids[NUM_PHILOSOPHERS];

    // Initialize semaphores for forks
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        sem_init(&forks[i], 0, 1);  // Each fork is initially available (semaphore value = 1)
    }

    // Create philosopher threads
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        philosopher_ids[i] = i;
        pthread_create(&philosophers[i], NULL, philosopher, &philosopher_ids[i]);
    }

    // Join threads (although in this infinite loop, they will never actually terminate)
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        pthread_join(philosophers[i], NULL); // waits for a thread to finish executing
    }

    // Destroy semaphores (not reached due to infinite loop)
    for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
        sem_destroy(&forks[i]);
    }

    return 0;
}









1)
#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<semaphore.h>
#include<unistd.h>
#include<time.h>
#define N 5
#define THINKING 0
#define HUNGRY 1
#define EATING 2
sem_t s,semaphores[N];
int states[N];

void thinking(int philNumber)
{
    states[philNumber] = THINKING;
    printf("\nPhilosopher %d is thinking.\n",philNumber);
    usleep(rand() % 2000000);
}

void test(int philNumber)
{
    if(states[philNumber]==HUNGRY && states[(philNumber+1)%N]!=EATING && states[(philNumber-1+N)%N]!=EATING )
    {
        states[philNumber] = EATING;
        sem_post(&semaphores[philNumber]);
    }
}

void takeForks(int philNumber)
{
    sem_wait(&s);
    states[philNumber] = HUNGRY;
    printf("\nPhilosopher %d is hungry.\n",philNumber);
    test(philNumber);
    sem_post(&s);
    sem_wait(&semaphores[philNumber]);
}

void eating(int philNumber)
{
    states[philNumber] = EATING;
    printf("\nPhilosopher %d is eating.\n",philNumber);
    usleep(rand() % 2000000);
}

void putForks(int philNumber)
{
    sem_wait(&s);
    states[philNumber] = THINKING;
    printf("\nPhilosopher %d has done eating.\n",philNumber);
    test((philNumber+1)%N);
    test((philNumber-1+N)%N);
    sem_post(&s);
}

void *philosopher(void *args)
{
    int philNumber = *(int *)args;
    thinking(philNumber);
    takeForks(philNumber);
    eating(philNumber);
    putForks(philNumber);
}

void main()
{
    srand(time(NULL));
    pthread_t threads[N];
    int philNumber[N];

    sem_init(&s,0,1);
    for(int i = 0 ; i < N ; i++)
    {
        philNumber[i] = i;
        sem_init(&semaphores[i],0,0);
    }

    for(int i = 0 ; i < N ; i++)
    {
        pthread_create(&threads[i],NULL,philosopher,&philNumber[i]);
    }

    for(int i = 0 ; i < N ; i++)
    {
        pthread_join(threads[i],NULL);
    }


    sem_destroy(&s);
    for(int i = 0 ; i < N ; i++)
        sem_destroy(&semaphores[i]);
}




2)

//din count sema
#include<stdio.h>
#include<stdlib.h>
#include<pthread.h>
#include<semaphore.h>
#include<unistd.h>
#include<time.h>
#define N 5
#define THINKING 0
#define HUNGRY 1
#define EATING 2
sem_t s, semaphores[N];
int states[N];

void thinking(int philNumber) {
    states[philNumber] = THINKING;
    printf("\nPhilosopher %d is thinking.\n", philNumber);
    usleep(rand() % 2000000);
}

void test(int philNumber) {
    if (states[philNumber] == HUNGRY && states[(philNumber + 1) % N] != EATING && states[(philNumber - 1 + N) % N] != EATING) {
        states[philNumber] = EATING;
        sem_post(&semaphores[philNumber]);
    }
}

void takeForks(int philNumber) {
    sem_wait(&s);  // Counting semaphore, allowing up to N - 1 philosophers to try accessing
    states[philNumber] = HUNGRY;
    printf("\nPhilosopher %d is hungry.\n", philNumber);
    test(philNumber);
    sem_post(&s);
    sem_wait(&semaphores[philNumber]);
}

void eating(int philNumber) {
    states[philNumber] = EATING;
    printf("\nPhilosopher %d is eating.\n", philNumber);
    usleep(rand() % 2000000);
}

void putForks(int philNumber) {
    sem_wait(&s); 
    states[philNumber] = THINKING;
    printf("\nPhilosopher %d has done eating.\n", philNumber);
    test((philNumber + 1) % N);
    test((philNumber - 1 + N) % N);
    sem_post(&s); 
}

void *philosopher(void *args) {
    int philNumber = *(int *)args;
    thinking(philNumber);
    takeForks(philNumber);
    eating(philNumber);
    putForks(philNumber);
}

int main() {
    srand(time(NULL));
    pthread_t threads[N];
    int philNumber[N];

    sem_init(&s, 0, N - 1);  // Initialize counting semaphore to N - 1
    for (int i = 0; i < N; i++) {
        philNumber[i] = i;
        sem_init(&semaphores[i], 0, 0);
    }

    for (int i = 0; i < N; i++) {
        pthread_create(&threads[i], NULL, philosopher, &philNumber[i]);
    }

    for (int i = 0; i < N; i++) {
        pthread_join(threads[i], NULL);
    }

    sem_destroy(&s);
    for (int i = 0; i < N; i++)
        sem_destroy(&semaphores[i]);
    return 0;
}



------------------------------------------------------------------------------------------------------------------------------


8.Implementation of Classical problems (dining philosopher) using Threads and Mutex. 


#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define PHILOSOPHERS 5

pthread_mutex_t forks[PHILOSOPHERS]; // Mutexes for forks

void* philosopher(void* num) {
    int id = *((int*)num);
    
    while (1) {
        printf("Philosopher %d is thinking...\n", id);
        sleep(rand() % 3); // Philosopher is thinking

        // Pick up both forks
        // To avoid deadlock, always pick up the lower-numbered fork first
        if (id % 2 == 0) { // Even numbered philosophers pick up the left fork first
            pthread_mutex_lock(&forks[id]); // Pick up left fork
            pthread_mutex_lock(&forks[(id + 1) % PHILOSOPHERS]); // Pick up right fork
        } else { // Odd numbered philosophers pick up the right fork first
            pthread_mutex_lock(&forks[(id + 1) % PHILOSOPHERS]); // Pick up right fork
            pthread_mutex_lock(&forks[id]); // Pick up left fork
        }

        // Eating
        printf("Philosopher %d is eating...\n", id);
        sleep(rand() % 3); // Philosopher is eating

        // Put down both forks
        pthread_mutex_unlock(&forks[(id + 1) % PHILOSOPHERS]); // Put down right fork
        pthread_mutex_unlock(&forks[id]); // Put down left fork
    }
}

int main() {
    pthread_t philosophers[PHILOSOPHERS];
    int ids[PHILOSOPHERS];

    // Initialize mutexes
    for (int i = 0; i < PHILOSOPHERS; i++) {
        pthread_mutex_init(&forks[i], NULL); // Initialize each fork mutex
    }

    // Create philosopher threads
    for (int i = 0; i < PHILOSOPHERS; i++) {
        ids[i] = i;
        pthread_create(&philosophers[i], NULL, philosopher, (void*)&ids[i]);
    }

    // Wait for philosopher threads to finish (they won't, in this case)
    for (int i = 0; i < PHILOSOPHERS; i++) {
        pthread_join(philosophers[i], NULL);
    }

    // Clean up (this code will never be reached)
    for (int i = 0; i < PHILOSOPHERS; i++) {
        pthread_mutex_destroy(&forks[i]); // Destroy each fork mutex
    }

    return 0;
}



------------------------------------------------------------------------------------------------------------------------------



9. Write a program to compute the finish time, turnaround time and waiting time for the First come First serve.


#include <stdio.h>


struct Process {
    int pid;       // Process ID
    int arrivalTime;
    int burstTime;
    int finishTime;
    int turnAroundTime;
    int waitingTime;
};


void calculateTimes(struct Process processes[], int n) {
    int currentTime = 0;


    for (int i = 0; i < n; i++) {
        // If the process arrives after the current time, update the current time to the arrival time of the process
        if (currentTime < processes[i].arrivalTime) {
            currentTime = processes[i].arrivalTime;
        }


        // Finish time is the current time plus the burst time
        processes[i].finishTime = currentTime + processes[i].burstTime;


        // Turnaround time is finish time minus arrival time
        processes[i].turnAroundTime = processes[i].finishTime - processes[i].arrivalTime;


        // Waiting time is turnaround time minus burst time
        processes[i].waitingTime = processes[i].turnAroundTime - processes[i].burstTime;


        // Update current time to finish time of the current process
        currentTime = processes[i].finishTime;
    }
}


void displayResults(struct Process processes[], int n) {
    printf("PID\tArrival\tBurst\tFinish\tTurnaround\tWaiting\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t%d\t%d\t%d\t\t%d\n",
               processes[i].pid,
               processes[i].arrivalTime,
               processes[i].burstTime,
               processes[i].finishTime,
               processes[i].turnAroundTime,
               processes[i].waitingTime);
    }


    float totalTurnAroundTime = 0, totalWaitingTime = 0;
    for (int i = 0; i < n; i++) {
        totalTurnAroundTime += processes[i].turnAroundTime;
        totalWaitingTime += processes[i].waitingTime;
    }


    printf("Average Turnaround Time: %.2f\n", totalTurnAroundTime / n);
    printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
}


int main() {
    int n;


    printf("Enter the number of processes: ");
    scanf("%d", &n);


    struct Process processes[n];


    for (int i = 0; i < n; i++) {
        processes[i].pid = i + 1;
        printf("Enter arrival time and burst time for process %d: ", processes[i].pid);
        scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
    }


    // Sort processes by arrival time (FCFS scheduling)
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (processes[i].arrivalTime > processes[j].arrivalTime) {
                struct Process temp = processes[i];
                processes[i] = processes[j];
                processes[j] = temp;
            }
        }
    }


    calculateTimes(processes, n);
    displayResults(processes, n);


    return 0;
}
/*
Enter the number of processes: 4
Enter arrival time and burst time for process 1: 0 2
Enter arrival time and burst time for process 2: 1 2 
Enter arrival time and burst time for process 3: 5 3 
Enter arrival time and burst time for process 4: 6 4
PID     Arrival Burst   Finish  Turnaround      Waiting
1       0       2       2       2               0
2       1       2       4       3               1
3       5       3       8       3               0
4       6       4       12      6               2
Average Turnaround Time: 3.50
Average Waiting Time: 0.75 */




------------------------------------------------------------------------------------------------------------------------------



10.	Write a program to compute the finish time, turnaround time and waiting time for the
 Shortest Job First (Preemptive and Non Preemptive) 


#include <stdio.h>
#include <stdbool.h>


struct Process {
    int pid;          // Process ID
    int arrivalTime;
    int burstTime;
    int remainingTime; // For preemptive SJF
    int finishTime;
    int turnAroundTime;
    int waitingTime;
    bool isCompleted;
};


// Function for Non-Preemptive SJF
void sjfNonPreemptive(struct Process processes[], int n) {
    int currentTime = 0, completed = 0;


    while (completed < n) {
        int minIndex = -1;
        int minBurstTime = 1e9;


        // Select the process with the smallest burst time that has arrived
        for (int i = 0; i < n; i++) {
            if (!processes[i].isCompleted && processes[i].arrivalTime <= currentTime &&
                processes[i].burstTime < minBurstTime) {
                minBurstTime = processes[i].burstTime;
                minIndex = i;
            }
        }


        if (minIndex == -1) {
            currentTime++;
        } else {
            // Calculate the finish time, turnaround time, and waiting time
            processes[minIndex].finishTime = currentTime + processes[minIndex].burstTime;
            processes[minIndex].turnAroundTime = processes[minIndex].finishTime - processes[minIndex].arrivalTime;
            processes[minIndex].waitingTime = processes[minIndex].turnAroundTime - processes[minIndex].burstTime;
            processes[minIndex].isCompleted = true;


            currentTime = processes[minIndex].finishTime;
            completed++;
        }
    }
}


// Function for Preemptive SJF
void sjfPreemptive(struct Process processes[], int n) {
    int currentTime = 0, completed = 0;
    int minIndex = -1;
    int minRemainingTime = 1e9;


    while (completed < n) {
        minIndex = -1;
        minRemainingTime = 1e9;


        // Select the process with the smallest remaining time that has arrived
        for (int i = 0; i < n; i++) {
            if (processes[i].arrivalTime <= currentTime && !processes[i].isCompleted &&
                processes[i].remainingTime < minRemainingTime) {
                minRemainingTime = processes[i].remainingTime;
                minIndex = i;
            }
        }


        if (minIndex != -1) {
            processes[minIndex].remainingTime--;
            currentTime++;


            // If process is completed
            if (processes[minIndex].remainingTime == 0) {
                processes[minIndex].finishTime = currentTime;
                processes[minIndex].turnAroundTime = processes[minIndex].finishTime - processes[minIndex].arrivalTime;
                processes[minIndex].waitingTime = processes[minIndex].turnAroundTime - processes[minIndex].burstTime;
                processes[minIndex].isCompleted = true;
                completed++;
            }
        } else {
            currentTime++;
        }
    }
}


void displayResults(struct Process processes[], int n) {
    printf("PID\tArrival\tBurst\tFinish\tTurnaround\tWaiting\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t%d\t%d\t%d\t\t%d\n",
               processes[i].pid,
               processes[i].arrivalTime,
               processes[i].burstTime,
               processes[i].finishTime,
               processes[i].turnAroundTime,
               processes[i].waitingTime);
    }


    float totalTurnAroundTime = 0, totalWaitingTime = 0;
    for (int i = 0; i < n; i++) {
        totalTurnAroundTime += processes[i].turnAroundTime;
        totalWaitingTime += processes[i].waitingTime;
    }


    printf("Average Turnaround Time: %.2f\n", totalTurnAroundTime / n);
    printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
}


int main() {
    int n, choice;
    printf("Enter the number of processes: ");
    scanf("%d", &n);


    struct Process processes[n];
    for (int i = 0; i < n; i++) {
        processes[i].pid = i + 1;
        printf("Enter arrival time and burst time for process %d: ", processes[i].pid);
        scanf("%d %d", &processes[i].arrivalTime, &processes[i].burstTime);
        processes[i].remainingTime = processes[i].burstTime;
        processes[i].isCompleted = false;
    }


    printf("Choose Scheduling:\n1. Non-Preemptive SJF\n2. Preemptive SJF\n");
    scanf("%d", &choice);


    if (choice == 1) {
        sjfNonPreemptive(processes, n);
    } else if (choice == 2) {
        sjfPreemptive(processes, n);
    } else {
        printf("Invalid choice!\n");
        return 0;
    }


    displayResults(processes, n);
    return 0;
}

/*
3
0
6

2
8

4
7
1 or 2
*/






------------------------------------------------------------------------------------------------------------------------------


11.	Write a program to compute the finish time, turnaround time and waiting time for the
Priority (Preemptive and Non Preemptive)


#include <stdio.h>
#include <stdbool.h>

struct Process {
    int pid;          // Process ID
    int arrivalTime;
    int burstTime;
    int remainingTime; // For preemptive scheduling
    int priority;
    int finishTime;
    int turnAroundTime;
    int waitingTime;
    bool isCompleted;
};

// Function for Non-Preemptive Priority Scheduling
void priorityNonPreemptive(struct Process processes[], int n) {
    int currentTime = 0, completed = 0;

    while (completed < n) {
        int minIndex = -1;
        int highestPriority = 1e9;

        // Select the process with the highest priority that has arrived
        for (int i = 0; i < n; i++) {
            if (!processes[i].isCompleted && processes[i].arrivalTime <= currentTime &&
                processes[i].priority < highestPriority) {
                highestPriority = processes[i].priority;
                minIndex = i;
            }
        }

        if (minIndex == -1) {
            currentTime++;
        } else {
            // Calculate the finish time, turnaround time, and waiting time
            processes[minIndex].finishTime = currentTime + processes[minIndex].burstTime;
            processes[minIndex].turnAroundTime = processes[minIndex].finishTime - processes[minIndex].arrivalTime;
            processes[minIndex].waitingTime = processes[minIndex].turnAroundTime - processes[minIndex].burstTime;
            processes[minIndex].isCompleted = true;

            currentTime = processes[minIndex].finishTime;
            completed++;
        }
    }
}

// Function for Preemptive Priority Scheduling
void priorityPreemptive(struct Process processes[], int n) {
    int currentTime = 0, completed = 0;
    int lastCompletedPid = -1; // To keep track of the last completed process

    while (completed < n) {
        int minIndex = -1;
        int highestPriority = 1e9;

        // Select the process with the highest priority that has arrived
        for (int i = 0; i < n; i++) {
            if (processes[i].arrivalTime <= currentTime && !processes[i].isCompleted &&
                processes[i].priority < highestPriority) {
                highestPriority = processes[i].priority;
                minIndex = i;
            }
        }

        if (minIndex != -1) {
            // Process one unit of the burst time
            processes[minIndex].remainingTime--;
            currentTime++;

            // If process is completed
            if (processes[minIndex].remainingTime == 0) {
                processes[minIndex].finishTime = currentTime;
                processes[minIndex].turnAroundTime = processes[minIndex].finishTime - processes[minIndex].arrivalTime;
                processes[minIndex].waitingTime = processes[minIndex].turnAroundTime - processes[minIndex].burstTime;
                processes[minIndex].isCompleted = true;
                completed++;
            }
        } else {
            currentTime++;
        }
    }
}

void displayResults(struct Process processes[], int n) {
    printf("PID\tArrival\tBurst\tPriority\tFinish\tTurnaround\tWaiting\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t%d\t%d\t\t%d\t%d\t\t%d\n",
               processes[i].pid,
               processes[i].arrivalTime,
               processes[i].burstTime,
               processes[i].priority,
               processes[i].finishTime,
               processes[i].turnAroundTime,
               processes[i].waitingTime);
    }

    float totalTurnAroundTime = 0, totalWaitingTime = 0;
    for (int i = 0; i < n; i++) {
        totalTurnAroundTime += processes[i].turnAroundTime;
        totalWaitingTime += processes[i].waitingTime;
    }

    printf("Average Turnaround Time: %.2f\n", totalTurnAroundTime / n);
    printf("Average Waiting Time: %.2f\n", totalWaitingTime / n);
}

int main() {
    int n, choice;
    printf("Enter the number of processes: ");
    scanf("%d", &n);

    struct Process processes[n];
    for (int i = 0; i < n; i++) {
        processes[i].pid = i + 1;
        printf("Enter arrival time, burst time, and priority for process %d: ", processes[i].pid);
        scanf("%d %d %d", &processes[i].arrivalTime, &processes[i].burstTime, &processes[i].priority);
        processes[i].remainingTime = processes[i].burstTime;
        processes[i].isCompleted = false;
    }

    printf("Choose Scheduling:\n1. Non-Preemptive Priority\n2. Preemptive Priority\n");
    scanf("%d", &choice);

    if (choice == 1) {
        priorityNonPreemptive(processes, n);
    } else if (choice == 2) {
        priorityPreemptive(processes, n);
    } else {
        printf("Invalid choice!\n");
        return 0;
    }

    displayResults(processes, n);
    return 0;
}


/* 4
0
5
10
1
4
20
2
2
30
4
1
40
1 or 2 
*/





------------------------------------------------------------------------------------------------------------------------------


12.	Write a program to compute the finish time, turnaround time and waiting time for the
 Round robin 









------------------------------------------------------------------------------------------------------------------------------


13.	Write a program to check whether given system is in safe state or not using Bankers  Deadlock Avoidance algorithm.

#include <stdio.h>
#include <stdbool.h>


#define MAX_PROCESSES 10
#define MAX_RESOURCES 10


int processes, resources;
int available[MAX_RESOURCES];
int max[MAX_PROCESSES][MAX_RESOURCES];
int allocation[MAX_PROCESSES][MAX_RESOURCES];
int need[MAX_PROCESSES][MAX_RESOURCES];


void calculateNeed() {
    for (int i = 0; i < processes; i++) {
        for (int j = 0; j < resources; j++) {
            need[i][j] = max[i][j] - allocation[i][j];
        }
    }
}


bool isSafeState() {
    int work[MAX_RESOURCES];
    bool finish[MAX_PROCESSES] = {false};
    int safeSequence[MAX_PROCESSES];
    int count = 0;


    // Initialize work as a copy of available resources
    for (int i = 0; i < resources; i++) {
        work[i] = available[i];
    }


    while (count < processes) {
        bool found = false;


        for (int i = 0; i < processes; i++) {
            if (!finish[i]) {
                bool canAllocate = true;


                for (int j = 0; j < resources; j++) {
                    if (need[i][j] > work[j]) {
                        canAllocate = false;
                        break;
                    }
                }


                if (canAllocate) {
                    for (int k = 0; k < resources; k++) {
                        work[k] += allocation[i][k];
                    }
                    safeSequence[count++] = i;
                    finish[i] = true;
                    found = true;
                }
            }
        }


        if (!found) {
            printf("System is not in a safe state.\n");
            return false;
        }
    }


    printf("System is in a safe state.\nSafe sequence is: ");
    for (int i = 0; i < processes; i++) {
        printf("P%d ", safeSequence[i]);
    }
    printf("\n");
    return true;
}


int main() {
    printf("Enter the number of processes: ");
    scanf("%d", &processes);


    printf("Enter the number of resources: ");
    scanf("%d", &resources);


    printf("Enter the available resources:\n");
    for (int i = 0; i < resources; i++) {
        scanf("%d", &available[i]);
    }


    printf("Enter the maximum resource matrix:\n");
    for (int i = 0; i < processes; i++) {
        for (int j = 0; j < resources; j++) {
            scanf("%d", &max[i][j]);
        }
    }


    printf("Enter the allocation matrix:\n");
    for (int i = 0; i < processes; i++) {
        for (int j = 0; j < resources; j++) {
            scanf("%d", &allocation[i][j]);
        }
    }


    calculateNeed();
    isSafeState();


    return 0;
}

/* 5
3
3 2 1
7 5 3
3 2 2
9 0 2
2 2 2
4 3 3
0 1 0
2 0 0
3 0 2
2 1 1
0 0 2 
*/





------------------------------------------------------------------------------------------------------------------------------



14.	Write a program for Deadlock detection algorithm

#include <stdio.h>
#include <stdbool.h>


#define MAX_PROCESSES 10
#define MAX_RESOURCES 10


int processes, resources;
int available[MAX_RESOURCES];
int allocation[MAX_PROCESSES][MAX_RESOURCES];
int request[MAX_PROCESSES][MAX_RESOURCES];


void deadlockDetection() {
    bool finish[MAX_PROCESSES] = {false};
    int work[MAX_RESOURCES];


    // Initialize work as a copy of available resources
    for (int i = 0; i < resources; i++) {
        work[i] = available[i];
    }


    bool deadlock = false;
    int deadlockedProcesses[MAX_PROCESSES];
    int deadlockedCount = 0;


    for (int count = 0; count < processes; count++) {
        bool found = false;


        for (int i = 0; i < processes; i++) {
            if (!finish[i]) {
                bool canProceed = true;


                // Check if the process's request can be satisfied
                for (int j = 0; j < resources; j++) {
                    if (request[i][j] > work[j]) {
                        canProceed = false;
                        break;
                    }
                }


                // If the request can be satisfied, allocate resources temporarily
                if (canProceed) {
                    for (int j = 0; j < resources; j++) {
                        work[j] += allocation[i][j];
                    }
                    finish[i] = true;
                    found = true;
                }
            }
        }


        // If no process could proceed in this round, break out
        if (!found) {
            break;
        }
    }


    // Check for processes still marked as unfinished
    for (int i = 0; i < processes; i++) {
        if (!finish[i]) {
            deadlockedProcesses[deadlockedCount++] = i;
            deadlock = true;
        }
    }


    if (deadlock) {
        printf("System is in a deadlock state.\n");
        printf("Deadlocked processes: ");
        for (int i = 0; i < deadlockedCount; i++) {
            printf("P%d ", deadlockedProcesses[i]);
        }
        printf("\n");
    } else {
        printf("System is not in a deadlock state.\n");
    }
}


int main() {
    printf("Enter the number of processes: ");
    scanf("%d", &processes);


    printf("Enter the number of resources: ");
    scanf("%d", &resources);


    printf("Enter the available resources:\n");
    for (int i = 0; i < resources; i++) {
        scanf("%d", &available[i]);
    }


    printf("Enter the allocation matrix:\n");
    for (int i = 0; i < processes; i++) {
        for (int j = 0; j < resources; j++) {
            scanf("%d", &allocation[i][j]);
        }
    }


    printf("Enter the request matrix:\n");
    for (int i = 0; i < processes; i++) {
        for (int j = 0; j < resources; j++) {
            scanf("%d", &request[i][j]);
        }
    }


    deadlockDetection();


    return 0;
}

/*Enter the number of processes: 3
Enter the number of resources: 3
Enter the available resources:
3 4 5
Enter the allocation matrix:
1 2 3
3 4 5
5 6 7
Enter the request matrix:
4 8 6
3 4 6 
9 2 1
System is in a deadlock state.
Deadlocked processes: P0 P1 P2 */





------------------------------------------------------------------------------------------------------------------------------



15.	Write a program to calculate the number of page faults for a reference string for the FIFO page replacement algorithms:


#include <stdio.h>


#define MAX_FRAMES 10


int isPageInFrames(int frames[], int frameCount, int page) {
    for (int i = 0; i < frameCount; i++) {
        if (frames[i] == page) {
            return 1; // Page found in frames
        }
    }
    return 0; // Page not found
}


int main() {
    int frameCount, pageCount;
    int pageFaults = 0;
    int nextFrameToReplace = 0; // To keep track of which frame to replace next


    // Input: Number of frames and number of pages in the reference string
    printf("Enter the number of frames: ");
    scanf("%d", &frameCount);


    printf("Enter the number of pages in the reference string: ");
    scanf("%d", &pageCount);


    int pages[pageCount];
    printf("Enter the reference string (space-separated): ");
    for (int i = 0; i < pageCount; i++) {
        scanf("%d", &pages[i]);
    }


    int frames[MAX_FRAMES];
    for (int i = 0; i < frameCount; i++) {
        frames[i] = -1; // Initialize frames as empty
    }


    // Processing each page in the reference string
    for (int i = 0; i < pageCount; i++) {
        int currentPage = pages[i];


        // Check if the current page is already in the frames
        if (!isPageInFrames(frames, frameCount, currentPage)) {
            // Page fault occurs as the page is not in frames
            frames[nextFrameToReplace] = currentPage; // Replace the page at nextFrameToReplace
            pageFaults++; // Increment page faults
            nextFrameToReplace = (nextFrameToReplace + 1) % frameCount; // Move to the next frame
        }
    }


    printf("\nTotal Page Faults: %d\n", pageFaults);


    return 0;
}

/*Enter the number of frames: 3
Enter the number of pages in the reference string: 6
Enter the reference string (space-separated): 1 2 3 4 5 3

Total Page Faults: 5*/






------------------------------------------------------------------------------------------------------------------------------

16.	Write a program to calculate the number of page faults for a reference string for the LRU page replacement algorithms:


#include <stdio.h>

int find_LRU(int time[], int n) {
    int min = time[0], pos = 0;
    for (int i = 1; i < n; i++) {
        if (time[i] < min) {
            min = time[i];
            pos = i;
        }
    }
    return pos;
}

int page_faults_LRU(int pages[], int n, int capacity) {
    int frame[capacity]; // Holds pages in memory
    int time[capacity];  // Tracks the time each page was last used
    int page_faults = 0, counter = 0;

    // Initialize frames with -1 to represent empty slots
    for (int i = 0; i < capacity; i++) {
        frame[i] = -1;
    }

    for (int i = 0; i < n; i++) {
        int page = pages[i];
        int found = 0;

        // Check if the page is already in the frame
        for (int j = 0; j < capacity; j++) {
            if (frame[j] == page) {
                found = 1;  // Page is found in frame
                time[j] = counter++; // Update last used time
                break;
            }
        }

        // If page is not found, it is a page fault
        if (!found) {
            int pos = -1;

            // If there is an empty slot, find it
            for (int j = 0; j < capacity; j++) {
                if (frame[j] == -1) {
                    pos = j;
                    break;
                }
            }

            // If no empty slot, replace the LRU page
            if (pos == -1) {
                pos = find_LRU(time, capacity);
            }

            // Replace the page at the LRU position with the new page
            frame[pos] = page;
            time[pos] = counter++;
            page_faults++;
        }

        // Display current frame contents
        printf("Frame: ");
        for (int j = 0; j < capacity; j++) {
            if (frame[j] == -1)
                printf("- ");
            else
                printf("%d ", frame[j]);
        }
        printf("\n");
    }

    return page_faults;
}

int main() {
    int n, capacity;

    printf("Enter the number of pages: ");
    scanf("%d", &n);

    int pages[n];
    printf("Enter the reference string (page numbers): ");
    for (int i = 0; i < n; i++)
        scanf("%d", &pages[i]);

    printf("Enter the frame capacity: ");
    scanf("%d", &capacity);

    int faults = page_faults_LRU(pages, n, capacity);
    printf("Total page faults: %d\n", faults);

    return 0;
}

/*Enter the number of pages: 7
Enter the reference string (page numbers): 0 1 2 0 3 1 2
Enter the frame capacity: 3*/




------------------------------------------------------------------------------------------------------------------------------


17.	Write a program to calculate the number of page faults for a reference string for the Optimal page replacement algorithms:


#include <stdio.h>


#define MAX_FRAMES 10


int findOptimal(int frames[], int frameCount, int pages[], int pageCount, int currentIndex) {
    int farthest = currentIndex, indexToReplace = -1;


    for (int i = 0; i < frameCount; i++) {
        int j;
        for (j = currentIndex; j < pageCount; j++) {
            if (frames[i] == pages[j]) {
                if (j > farthest) {
                    farthest = j;
                    indexToReplace = i;
                }
                break;
            }
        }
        // If the frame is never going to be used again
        if (j == pageCount) {
            return i; // Replace this frame
        }
    }
   
    // If all pages are used in the future, replace the one that is used the farthest in the future
    return (indexToReplace != -1) ? indexToReplace : 0;
}


int isPageInFrames(int frames[], int frameCount, int page) {
    for (int i = 0; i < frameCount; i++) {
        if (frames[i] == page) {
            return 1; // Page found in frames
        }
    }
    return 0; // Page not found
}


int main() {
    int frameCount, pageCount;
    int pageFaults = 0;


    // Input: Number of frames and number of pages in the reference string
    printf("Enter the number of frames: ");
    scanf("%d", &frameCount);


    printf("Enter the number of pages in the reference string: ");
    scanf("%d", &pageCount);


    int pages[pageCount];
    printf("Enter the reference string (space-separated): ");
    for (int i = 0; i < pageCount; i++) {
        scanf("%d", &pages[i]);
    }


    int frames[MAX_FRAMES];
    for (int i = 0; i < frameCount; i++) {
        frames[i] = -1; // Initialize frames as empty
    }


    // Processing each page in the reference string
    for (int i = 0; i < pageCount; i++) {
        int currentPage = pages[i];


        // Check if the current page is already in the frames
        if (!isPageInFrames(frames, frameCount, currentPage)) {
            // Page fault occurs as the page is not in frames
            int indexToReplace = findOptimal(frames, frameCount, pages, pageCount, i); // Find the optimal frame to replace
            frames[indexToReplace] = currentPage; // Replace the optimal frame with the current page
            pageFaults++; // Increment page faults
        }
    }


    printf("\nTotal Page Faults: %d\n", pageFaults);


    return 0;
}


/* 
4
20
7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1
*/





------------------------------------------------------------------------------------------------------------------------------

18.	Write a program to simulate FCFS disk scheduling. Calculate total seek time.Print accepted input and output in tabular format


#include <stdio.h>
#include <stdlib.h>


void calculateFCFS(int requests[], int n, int initial_head) {
    int total_seek_time = 0;
    int current_head = initial_head;


    printf("\nDisk Scheduling using FCFS Algorithm:\n");
    printf("------------------------------------------------\n");
    printf("| Request No. |  Request   |  Seek Time      |\n");
    printf("------------------------------------------------\n");
   
    for (int i = 0; i < n; i++) {
        int seek_time = abs(requests[i] - current_head);
        total_seek_time += seek_time;
        printf("|      %2d      |    %3d     |     %3d        |\n", i + 1, requests[i], seek_time);
        current_head = requests[i];
    }


    printf("------------------------------------------------\n");
    printf("Total Seek Time: %d\n", total_seek_time);
}


int main() {
    int n;
    int initial_head;


    // Accept number of requests and initial head position
    printf("Enter the number of disk requests: ");
    scanf("%d", &n);


    int requests[n];
    printf("Enter the initial head position: ");
    scanf("%d", &initial_head);


    printf("Enter the disk requests: \n");
    for (int i = 0; i < n; i++) {
        printf("Request %d: ", i + 1);
        scanf("%d", &requests[i]);
    }


    // Calculate and display the FCFS scheduling
    calculateFCFS(requests, n, initial_head);


    return 0;
}

/*Enter the number of disk requests: 6
Enter the initial head position: 50
Enter the disk requests: 
Request 1: 82 170 43 140 24 16 190
Request 2: Request 3: Request 4: Request 5: Request 6: 
Disk Scheduling using FCFS Algorithm:
------------------------------------------------
| Request No. |  Request   |  Seek Time      |
------------------------------------------------
|       1      |     82     |      32        |
|       2      |    170     |      88        |
|       3      |     43     |     127        |
|       4      |    140     |      97        |
|       5      |     24     |     116        |
|       6      |     16     |       8        |
------------------------------------------------
Total Seek Time: 468*/





------------------------------------------------------------------------------------------------------------------------------

19.	Write a program to simulate SSTF disk scheduling. Calculate total seek time.Print accepted input and output in tabular format



#include <stdio.h>
#include <stdlib.h>


void calculateSSTF(int requests[], int n, int initial_head) {
    int total_seek_time = 0;
    int current_head = initial_head;
    int visited[n];  // Array to keep track of visited requests
    int i, count = 0;


    // Initialize the visited array
    for (i = 0; i < n; i++) {
        visited[i] = 0;
    }


    printf("\nDisk Scheduling using SSTF Algorithm:\n");
    printf("------------------------------------------------\n");
    printf("| Request No. |  Request   |  Seek Time      |\n");
    printf("------------------------------------------------\n");
   
    while (count < n) {
        int min_seek_time = 10000; // Arbitrary large value
        int min_index = -1;


        // Find the closest request
        for (i = 0; i < n; i++) {
            if (!visited[i]) {
                int seek_time = abs(requests[i] - current_head);
                if (seek_time < min_seek_time) {
                    min_seek_time = seek_time;
                    min_index = i;
                }
            }
        }


        // Process the closest request
        if (min_index != -1) {
            total_seek_time += min_seek_time; // Update total seek time
            printf("|      %2d      |    %3d     |     %3d        |\n", count + 1, requests[min_index], min_seek_time);
            current_head = requests[min_index]; // Move head to the current request
            visited[min_index] = 1; // Mark this request as visited
            count++;
        }
    }


    printf("------------------------------------------------\n");
    printf("Total Seek Time: %d\n", total_seek_time); // Display total seek time
}


int main() {
    int n;
    int initial_head;


    // Accept number of requests and initial head position
    printf("Enter the number of disk requests: ");
    scanf("%d", &n);


    int requests[n];
    printf("Enter the initial head position: ");
    scanf("%d", &initial_head);


    printf("Enter the disk requests: \n");
    for (int i = 0; i < n; i++) {
        printf("Request %d: ", i + 1);
        scanf("%d", &requests[i]);
    }


    // Calculate and display the SSTF scheduling
    calculateSSTF(requests, n, initial_head);


    return 0;
}

/*
7
50
82
170   
43
140
24
16
190
*/





------------------------------------------------------------------------------------------------------------------------------



20.	Write a program to simulate SCAN disk scheduling. Calculate total seek time.Print accepted input and output in tabular format


#include <stdio.h>
#include <stdlib.h>

void sort(int arr[], int n) {
for (int i = 0; i < n - 1; i++) {
for (int j = 0; j < n - i - 1; j++) {
if (arr[j] > arr[j + 1]) {
int temp = arr[j];
arr[j] = arr[j + 1];
arr[j + 1] = temp;
}
}
}
}

void print_table(int seek_sequence[], int seek_count, int total_seek_time) {
printf("\nDisk Scheduling - SCAN\n");
printf("------------------------------------------------\n");
printf("| Request Order | Position | Seek Time (Head -> Request) |\n");
printf("------------------------------------------------\n");

int current_position = seek_sequence[0];
for (int i = 1; i <= seek_count; i++) {
int seek_distance = abs(seek_sequence[i] - current_position);
printf("| %2d | %3d | %3d ms |\n", i, seek_sequence[i], seek_distance);
current_position = seek_sequence[i];
}
printf("------------------------------------------------\n");
printf("| Total Seek Time: %d ms |\n", total_seek_time);
printf("------------------------------------------------\n");
}

int scan_disk_scheduling(int requests[], int n, int head, int disk_size, int direction) {
int seek_sequence[n + 1];
int total_seek_time = 0;
int seek_count = 0;

// Add initial head position to seek sequence
seek_sequence[seek_count++] = head;

// Sort the requests
sort(requests, n);

int current_position = head;
int closest_index = 0;

// Find the closest request in the chosen direction
for (int i = 0; i < n; i++) {
if (requests[i] >= head) {
closest_index = i;
break;
}
}

// SCAN in the specified direction (0 = left, 1 = right)
if (direction == 1) {
// Move towards the end of the disk
for (int i = closest_index; i < n; i++) {
seek_sequence[seek_count++] = requests[i];
total_seek_time += abs(current_position - requests[i]);
current_position = requests[i];
}
// After reaching end, reverse direction if needed
if (current_position < disk_size - 1) {
total_seek_time += abs(current_position - (disk_size - 1));
current_position = disk_size - 1;
seek_sequence[seek_count++] = current_position;
}
// Move back towards the start
for (int i = closest_index - 1; i >= 0; i--) {
seek_sequence[seek_count++] = requests[i];
total_seek_time += abs(current_position - requests[i]);
current_position = requests[i];
}
} else {
// Move towards the start of the disk
for (int i = closest_index - 1; i >= 0; i--) {
seek_sequence[seek_count++] = requests[i];
total_seek_time += abs(current_position - requests[i]);
current_position = requests[i];
}
// After reaching start, reverse direction if needed
if (current_position > 0) {
total_seek_time += abs(current_position - 0);
current_position = 0;
seek_sequence[seek_count++] = current_position;
}
// Move back towards the end
for (int i = closest_index; i < n; i++) {
seek_sequence[seek_count++] = requests[i];
total_seek_time += abs(current_position - requests[i]);
current_position = requests[i];
}
}

// Display the table
print_table(seek_sequence, seek_count - 1, total_seek_time);
return total_seek_time;
}

int main() {
int n, head, disk_size, direction;

// Input: Number of disk requests
printf("Enter the number of disk requests: ");
scanf("%d", &n);

int requests[n];

// Input: Disk request sequence
printf("Enter the disk requests (in sequence): ");
for (int i = 0; i < n; i++) {
scanf("%d", &requests[i]);
}

// Input: Disk size and initial head position
printf("Enter the disk size: ");
scanf("%d", &disk_size);

printf("Enter the initial head position: ");
scanf("%d", &head);

// Input: Direction (0 for left, 1 for right)
printf("Enter the direction (0 = left, 1 = right): ");
scanf("%d", &direction);

// Calculate total seek time using SCAN
int total_seek_time = scan_disk_scheduling(requests, n, head, disk_size, direction);

printf("Total Seek Time using SCAN: %d ms\n", total_seek_time);

return 0;
}

/*
7
200
50
82 170 43 140 24 16 190
*/





------------------------------------------------------------------------------------------------------------------------------



21.	Write a program to simulate C-SCAN disk scheduling. Calculate total seek time.Print accepted input and output in tabular format


#include <stdio.h>
#include <stdlib.h>


void calculateCSCAN(int requests[], int n, int initial_head, int disk_size, int direction) {
    int total_seek_time = 0;
    int current_head = initial_head;


    // Sort the requests in ascending order
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (requests[j] > requests[j + 1]) {
                int temp = requests[j];
                requests[j] = requests[j + 1];
                requests[j + 1] = temp;
            }
        }
    }


    // Find the starting index where the head should start servicing requests
    int start_index = 0;
    while (start_index < n && requests[start_index] < initial_head) {
        start_index++;
    }


    printf("\nDisk Scheduling using C-SCAN Algorithm:\n");
    printf("------------------------------------------------\n");
    printf("| Request No. |  Request   |  Seek Time      |\n");
    printf("------------------------------------------------\n");


    // Move in the selected direction
    if (direction == 1) {  // Moving right towards higher values
        // Service requests to the right of the initial head position
        for (int i = start_index; i < n; i++) {
            int seek_time = abs(requests[i] - current_head);
            total_seek_time += seek_time;
            printf("|      %2d      |    %3d     |     %3d        |\n", i - start_index + 1, requests[i], seek_time);
            current_head = requests[i];
        }


        // Move to the end of the disk, if not already there, and then jump to the start
        if (current_head < disk_size - 1) {
            int end_seek_time = abs(disk_size - 1 - current_head);
            total_seek_time += end_seek_time;
            printf("|      -       |   %3d     |     %3d        |\n", disk_size - 1, end_seek_time);
        }
        int reset_seek_time = disk_size - 1;  // Jump from end to start
        total_seek_time += reset_seek_time;
        printf("|      -       |     0     |     %3d        |\n", reset_seek_time);
        current_head = 0;


        // Continue servicing the remaining requests from the start
        for (int i = 0; i < start_index; i++) {
            int seek_time = abs(requests[i] - current_head);
            total_seek_time += seek_time;
            printf("|      %2d      |    %3d     |     %3d        |\n", i + n - start_index + 1, requests[i], seek_time);
            current_head = requests[i];
        }
    } else {  // Moving left towards lower values
        // Service requests to the left of the initial head position
        for (int i = start_index - 1; i >= 0; i--) {
            int seek_time = abs(requests[i] - current_head);
            total_seek_time += seek_time;
            printf("|      %2d      |    %3d     |     %3d        |\n", start_index - i, requests[i], seek_time);
            current_head = requests[i];
        }


        // Move to the start of the disk and then jump to the end
        if (current_head > 0) {
            int start_seek_time = abs(current_head - 0);
            total_seek_time += start_seek_time;
            printf("|      -       |     0     |     %3d        |\n", start_seek_time);
        }
        int reset_seek_time = disk_size - 1;  // Jump from start to end
        total_seek_time += reset_seek_time;
        printf("|      -       |   %3d     |     %3d        |\n", disk_size - 1, reset_seek_time);
        current_head = disk_size - 1;


        // Continue servicing the remaining requests from the end
        for (int i = n - 1; i >= start_index; i--) {
            int seek_time = abs(requests[i] - current_head);
            total_seek_time += seek_time;
            printf("|      %2d      |    %3d     |     %3d        |\n", n - i, requests[i], seek_time);
            current_head = requests[i];
        }
    }


    printf("------------------------------------------------\n");
    printf("Total Seek Time: %d\n", total_seek_time); // Display total seek time
}


int main() {
    int n, initial_head, disk_size, direction;


    // Accept number of requests and initial head position
    printf("Enter the number of disk requests: ");
    scanf("%d", &n);


    int requests[n];
    printf("Enter the disk size: ");
    scanf("%d", &disk_size);


    printf("Enter the initial head position: ");
    scanf("%d", &initial_head);


    printf("Enter the direction (1 for right, 0 for left): ");
    scanf("%d", &direction);


    printf("Enter the disk requests: \n");
    for (int i = 0; i < n; i++) {
        printf("Request %d: ", i + 1);
        scanf("%d", &requests[i]);
    }


    // Calculate and display the C-SCAN scheduling
    calculateCSCAN(requests, n, initial_head, disk_size, direction);


    return 0;
}

//Enter the number of disk requests: 5
//Enter the disk size: 199
//Enter the initial head position: 50
//E//nter the direction (1 for right, 0 for left): 0
//Enter the disk requests: 
//Request 1: 4
//Request 2: 45
//Request 3: 67
//Request 4: 88
//Request 5: 156





------------------------------------------------------------------------------------------------------------------------------



22.	Write a program  for following 1)  zombie process 2)orphan processes 3)sum of even numbers of an array in parent and odd numbers of an array in child process


#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>


void createZombieProcess() {
    pid_t pid = fork();


    if (pid < 0) {
        perror("Fork failed");
        exit(1);
    }


    if (pid > 0) {  // Parent process
        printf("Parent process: Zombie process created. PID = %d\n", pid); 
      sleep(10);  
    } 
    else {  // Child process
        printf("Child process exiting to become zombie.\n");
        exit(0);  
    }
}
void createOrphanProcess() {
    pid_t pid = fork();
    if (pid < 0) {
        perror("Fork failed");
        exit(1);
    }


    if (pid > 0) {  // Parent process
        printf("Parent process exiting to create orphan process.\n");
        exit(0);  
    } 
    else {  // Child process
        sleep(5);  
        printf("Child process (orphan) continuing after parent termination. PID = %d\n", getpid());
    }
}
void sumEvenOdd(int arr[], int size) {
    pid_t pid = fork();


    if (pid < 0) {
        perror("Fork failed");
        exit(1);
    }
    if (pid > 0) {  // Parent process
        int evenSum = 0;
        for (int i = 0; i < size; i++) {
            if (arr[i] % 2 == 0) {
                evenSum += arr[i];
            }
        }
        printf("Parent process: Sum of even numbers = %d\n", evenSum);
        wait(NULL);  
    } 
    else {  // Child process
        int oddSum = 0;
        for (int i = 0; i < size; i++) {
            if (arr[i] % 2 != 0) {
                oddSum += arr[i];
            }
        }
        printf("Child process: Sum of odd numbers = %d\n", oddSum);
        exit(0);
    }
}
int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};  
    int size = sizeof(arr) / sizeof(arr[0]);
    printf("Calculating sum of even and odd numbers:\n");
    sumEvenOdd(arr, size);


    printf("\nCreating a zombie process:\n");
    createZombieProcess();
    sleep(5);  


    printf("\nCreating an orphan process:\n");
    createOrphanProcess();
    return 0;
}



------------------------------------------------------------------------------------------------------------------------------


23.	Write a shell script to perform following operations on   student database.
a) Insert b) Delete c)Update d)Search



#!/bin/bash



# Array to store records in the format "ID,name,grade"

declare -a student_records



show_menu() {

    echo "Select an operation:"

    echo "a) Insert a record"

    echo "b) Delete a record"

    echo "c) Update a record"

    echo "d) Search for a record"

    echo "e) Display all records"

    echo "f) Exit"

    read -p "Enter your choice: " choice

}



insert_record() {

    read -p "Enter Student ID: " id

    read -p "Enter Student Name: " name

    read -p "Enter Student Grade: " grade

    student_records+=("$id,$name,$grade")  # Add the new record to the array

    echo "Record inserted successfully."

}



delete_record() {

    read -p "Enter Student ID to delete: " id

    found=0

    for i in "${!student_records[@]}"; do

        # Check if the record starts with the given ID

        if [[ ${student_records[$i]} == $id,* ]]; then

            unset 'student_records[$i]'  # Remove the record from the array

            found=1

            echo "Record with ID $id deleted successfully."

            break

        fi

    done

    if [ $found -eq 0 ]; then

        echo "Record with ID $id not found."

    fi

}



update_record() {

    read -p "Enter Student ID to update: " id

    found=0

    for i in "${!student_records[@]}"; do

        # Check if the record starts with the given ID

        if [[ ${student_records[$i]} == $id,* ]]; then

            read -p "Enter new Student Name: " name

            read -p "Enter new Student Grade: " grade

            student_records[$i]="$id,$name,$grade"  # Update the record in the array

            found=1

            echo "Record with ID $id updated successfully."

            break

        fi

    done

    if [ $found -eq 0 ]; then

        echo "Record with ID $id not found."

    fi

}



search_record() {

    read -p "Enter Student ID to search: " id

    found=0

    for record in "${student_records[@]}"; do

        # Check if the record starts with the given ID

        if [[ $record == $id,* ]]; then

            echo "Record found: $record"

            found=1

            break

        fi

    done

    if [ $found -eq 0 ]; then

        echo "Record with ID $id not found."

    fi

}



display_records() {

    if [ ${#student_records[@]} -eq 0 ]; then

        echo "No records available."

    else

        echo "Current Records:"

        for record in "${student_records[@]}"; do

            echo "$record"

        done

    fi

}



while true; do

    show_menu

    case $choice in

        a|A) insert_record ;;

        b|B) delete_record ;;

        c|C) update_record ;;

        d|D) search_record ;;

        e|E) display_records ;;

        f|F) echo "Exiting..."; exit 0 ;;

        *) echo "Invalid option. Please try again." ;;

    esac

done

/* 
a
121
Digvijayy
A
c
121
Digvijayy
B
d
121
e
f
*/



------------------------------------------------------------------------------------------------------------------------------


24.	Write a program to read and copy the contents of file character by character, line by line.


#include <stdio.h>
#include <stdlib.h>


void copyFileCharacterByCharacter(const char *sourceFile, const char *destFile) {
    FILE *src = fopen(sourceFile, "r");
    FILE *dest = fopen(destFile, "w");
    if (src == NULL || dest == NULL) {
        perror("Error opening file");
        exit(1);
    }
    char ch;
    while ((ch = fgetc(src)) != EOF) {
        fputc(ch, dest);
    }
    printf("File copied character by character successfully.\n");
    fclose(src);
    fclose(dest);
}


void copyFileLineByLine(const char *sourceFile, const char *destFile) {
    FILE *src = fopen(sourceFile, "r");
    FILE *dest = fopen(destFile, "w");
    if (src == NULL || dest == NULL) {
        perror("Error opening file");
        exit(1);
    }
    char line[1024];
    while (fgets(line, sizeof(line), src) != NULL) {
        fputs(line, dest);
    }
    printf("File copied line by line successfully.\n");
    fclose(src);
    fclose(dest);
}


int main() {
    char sourceFile[100];
    char destFileChar[100];
    char destFileLine[100];


    printf("Enter the name of the source file: ");
    scanf("%s", sourceFile);


    printf("Enter the name of the destination file for character-by-character copy: ");
    scanf("%s", destFileChar);


    printf("Enter the name of the destination file for line-by-line copy: ");
    scanf("%s", destFileLine);
    printf("\nCopying file character by character...\n");
    copyFileCharacterByCharacter(sourceFile, destFileChar);
    printf("\nCopying file line by line...\n");
    copyFileLineByLine(sourceFile, destFileLine);
    return 0;
}

//Enter the name of the source file: copy.txt
//Enter the name of the destination file for character-by-character copy: char_copy
//Enter the name of the destination file for line-by-line copy: line_copy




------------------------------------------------------------------------------------------------------------------------------


25. ALP  load


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#define MAX_INSTRUCTIONS 100
#define MAX_LINE_LENGTH 50


void load_alp_to_memory(const char *file_path) {
    char main_memory[MAX_INSTRUCTIONS][MAX_LINE_LENGTH];
    FILE *file = fopen(file_path, "r");
    if (file == NULL) {
        printf("Error: Input file not found.\n");
        return;
    }


    int address = 0;
    while (fgets(main_memory[address], MAX_LINE_LENGTH, file) != NULL && address < MAX_INSTRUCTIONS) {
        main_memory[address][strcspn(main_memory[address], "\n")] = '\0'; // Remove newline character
        address++;
    }
    fclose(file);


    printf("ALP Program loaded into main memory:\n");
    for (int i = 0; i < address; i++) {
        printf("Address %d: %s\n", i, main_memory[i]);
    }
}


int main() {
    load_alp_to_memory("alp.txt");
    return 0;
}
/*ALP Program loaded into main memory:
Address 0: mov al, num1     ; Load num1 into AL
Address 1: add al, num2     ; Add num2 to AL (AL now contain
Address 2: s num1 + num2)
Address 3: mov result, al   ; Store the result*/



------------------------------------------------------------------------------------------------------------------------------



26. Write a program to check Opcode error in a given job and raise an interrupt.

#include <stdio.h>
#include <string.h>


#define MAX_INSTRUCTIONS 100
#define MAX_LINE_LENGTH 50


const char *valid_opcodes[] = {"LOAD", "STORE", "ADD", "SUB", "JMP", "HALT"};
#define NUM_OPCODES (sizeof(valid_opcodes) / sizeof(valid_opcodes[0]))


int is_valid_opcode(const char *opcode) {
    for (int i = 0; i < NUM_OPCODES; i++) {
        if (strcmp(opcode, valid_opcodes[i]) == 0) {
            return 1;
        }
    }
    return 0;
}


void check_opcode_errors(char main_memory[][MAX_LINE_LENGTH], int instruction_count) {
    for (int i = 0; i < instruction_count; i++) {
        char opcode[MAX_LINE_LENGTH];
        sscanf(main_memory[i], "%s", opcode);  // Extract the first word as opcode
        if (!is_valid_opcode(opcode)) {
            printf("Opcode error at address %d: Invalid opcode '%s'\n", i, opcode);
        }
    }
}


int main() {
    char main_memory[MAX_INSTRUCTIONS][MAX_LINE_LENGTH] = {
        "LOAD R1, 100",
        "STOREE R2, 200", // Invalid opcode for testing
        "ADD R1, R2",
        "INVALID_OP R3, 300" // Invalid opcode for testing
    };
    int instruction_count = 4;
    check_opcode_errors(main_memory, instruction_count);
    return 0;
}




------------------------------------------------------------------------------------------------------------------------------



27. operand


#include <stdio.h>
#include <string.h>


#define MAX_INSTRUCTIONS 100
#define MAX_LINE_LENGTH 50


void check_operand_errors(char main_memory[][MAX_LINE_LENGTH], int instruction_count) {
    for (int i = 0; i < instruction_count; i++) {
        int operand_count = 0;
        char *token = strtok(main_memory[i], " ,");
        // Count tokens after the opcode as operands
        while (token != NULL) {
            operand_count++;
            token = strtok(NULL, " ,");
        }
       
        if (operand_count < 3) { // Opcode + 2 operands
            printf("Operand error at address %d: Missing operand(s) in instruction '%s'\n", i, main_memory[i]);
        }
    }
}


int main() {
    char main_memory[MAX_INSTRUCTIONS][MAX_LINE_LENGTH] = {
        "LOAD R1, 100",
        "STORE R2", // Missing operand for testing
        "ADD R1, R2",
        "SUB R3" // Missing operand for testing
    };
    int instruction_count = 4;
    check_operand_errors(main_memory, instruction_count);
    return 0;
}




